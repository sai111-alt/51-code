C51 COMPILER V9.59.0.0   DALYA                                                             11/13/2024 14:57:20 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE DALYA
OBJECT MODULE PLACED IN .\Objects\Dalya.obj
COMPILER INVOKED BY: D:\RJ\Keil5\C51\BIN\C51.EXE Dalya.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\Da
                    -lya.lst) TABS(2) OBJECT(.\Objects\Dalya.obj)

line level    source

   1          #include "Delay.h"
   2          
   3          //引脚配置：
   4          sbit LCD_RS=P2^6;
   5          sbit LCD_RW=P2^5;
   6          sbit LCD_EN=P2^7;
   7          #define LCD_DataPort P0
   8          
   9          //函数定义：
  10          /**
  11            * @brief  LCD1602延时函数，12MHz调用可延时1ms
  12            * @param  无
  13            * @retval 无
  14            */
  15          void LCD_Delay()
  16          {
  17   1        unsigned char i, j;
  18   1      
  19   1        i = 2;
  20   1        j = 239;
  21   1        do
  22   1        {
  23   2          while (--j);
  24   2        } while (--i);
  25   1      }
  26          
  27          /**
  28            * @brief  LCD1602写命令
  29            * @param  Command 要写入的命令
  30            * @retval 无
  31            */
  32          void LCD_WriteCommand(unsigned char Command)
  33          {
  34   1        LCD_RS=0;
  35   1        LCD_RW=0;
  36   1        LCD_DataPort=Command;
  37   1        LCD_EN=1;
  38   1        LCD_Delay();
  39   1        LCD_EN=0;
  40   1        LCD_Delay();
  41   1      }
  42          
  43          /**
  44            * @brief  LCD1602写数据
  45            * @param  Data 要写入的数据
  46            * @retval 无
  47            */
  48          void LCD_WriteData(unsigned char Data)
  49          {
  50   1        LCD_RS=1;
  51   1        LCD_RW=0;
  52   1        LCD_DataPort=Data;
  53   1        LCD_EN=1;
  54   1        LCD_Delay();
C51 COMPILER V9.59.0.0   DALYA                                                             11/13/2024 14:57:20 PAGE 2   

  55   1        LCD_EN=0;
  56   1        LCD_Delay();
  57   1      }
  58          
  59          /**
  60            * @brief  LCD1602设置光标位置
  61            * @param  Line 行位置，范围：1~2
  62            * @param  Column 列位置，范围：1~16
  63            * @retval 无
  64            */
  65          void LCD_SetCursor(unsigned char Line,unsigned char Column)
  66          {
  67   1        if(Line==1)
  68   1        {
  69   2          LCD_WriteCommand(0x80|(Column-1));
  70   2        }
  71   1        else if(Line==2)
  72   1        {
  73   2          LCD_WriteCommand(0x80|(Column-1+0x40));
  74   2        }
  75   1      }
  76          
  77          /**
  78            * @brief  LCD1602初始化函数
  79            * @param  无
  80            * @retval 无
  81            */
  82          void LCD_Init()
  83          {
  84   1        LCD_WriteCommand(0x38);//八位数据接口，两行显示，5*7点阵
  85   1        LCD_WriteCommand(0x0c);//显示开，光标关，闪烁关
  86   1        LCD_WriteCommand(0x06);//数据读写操作后，光标自动加一，画面不动
  87   1        LCD_WriteCommand(0x01);//光标复位，清屏
  88   1      }
  89          
  90          /**
  91            * @brief  在LCD1602指定位置上显示一个字符
  92            * @param  Line 行位置，范围：1~2
  93            * @param  Column 列位置，范围：1~16
  94            * @param  Char 要显示的字符
  95            * @retval 无
  96            */
  97          void LCD_ShowChar(unsigned char Line,unsigned char Column,char Char)
  98          {
  99   1        LCD_SetCursor(Line,Column);
 100   1        LCD_WriteData(Char);
 101   1      }
 102          
 103          /**
 104            * @brief  在LCD1602指定位置开始显示所给字符串
 105            * @param  Line 起始行位置，范围：1~2
 106            * @param  Column 起始列位置，范围：1~16
 107            * @param  String 要显示的字符串
 108            * @retval 无
 109            */
 110          void LCD_ShowString(unsigned char Line,unsigned char Column,char *String)
 111          {
 112   1        unsigned char i;
 113   1        LCD_SetCursor(Line,Column);
 114   1        for(i=0;String[i]!='\0';i++)
 115   1        {
 116   2          LCD_WriteData(String[i]);
C51 COMPILER V9.59.0.0   DALYA                                                             11/13/2024 14:57:20 PAGE 3   

 117   2        }
 118   1      }
 119          
 120          /**
 121            * @brief  返回值=X的Y次方
 122            */
 123          int LCD_Pow(int X,int Y)
 124          {
 125   1        unsigned char i;
 126   1        int Result=1;
 127   1        for(i=0;i<Y;i++)
 128   1        {
 129   2          Result*=X;
 130   2        }
 131   1        return Result;
 132   1      }
 133          
 134          /**
 135            * @brief  在LCD1602指定位置开始显示所给数字
 136            * @param  Line 起始行位置，范围：1~2
 137            * @param  Column 起始列位置，范围：1~16
 138            * @param  Number 要显示的数字，范围：0~65535
 139            * @param  Length 要显示数字的长度，范围：1~5
 140            * @retval 无
 141            */
 142          void LCD_ShowNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length)
 143          {
 144   1        unsigned char i;
 145   1        LCD_SetCursor(Line,Column);
 146   1        for(i=Length;i>0;i--)
 147   1        {
 148   2          LCD_WriteData(Number/LCD_Pow(10,i-1)%10+'0');
 149   2        }
 150   1      }
 151          
 152          /**
 153            * @brief  在LCD1602指定位置开始以有符号十进制显示所给数字
 154            * @param  Line 起始行位置，范围：1~2
 155            * @param  Column 起始列位置，范围：1~16
 156            * @param  Number 要显示的数字，范围：-32768~32767
 157            * @param  Length 要显示数字的长度，范围：1~5
 158            * @retval 无
 159            */
 160          void LCD_ShowSignedNum(unsigned char Line,unsigned char Column,int Number,unsigned char Length)
 161          {
 162   1        unsigned char i;
 163   1        unsigned int Number1;
 164   1        LCD_SetCursor(Line,Column);
 165   1        if(Number>=0)
 166   1        {
 167   2          LCD_WriteData('+');
 168   2          Number1=Number;
 169   2        }
 170   1        else
 171   1        {
 172   2          LCD_WriteData('-');
 173   2          Number1=-Number;
 174   2        }
 175   1        for(i=Length;i>0;i--)
 176   1        {
 177   2          LCD_WriteData(Number1/LCD_Pow(10,i-1)%10+'0');
 178   2        }
C51 COMPILER V9.59.0.0   DALYA                                                             11/13/2024 14:57:20 PAGE 4   

 179   1      }
 180          
 181          /**
 182            * @brief  在LCD1602指定位置开始以十六进制显示所给数字
 183            * @param  Line 起始行位置，范围：1~2
 184            * @param  Column 起始列位置，范围：1~16
 185            * @param  Number 要显示的数字，范围：0~0xFFFF
 186            * @param  Length 要显示数字的长度，范围：1~4
 187            * @retval 无
 188            */
 189          void LCD_ShowHexNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length)
 190          {
 191   1        unsigned char i,SingleNumber;
 192   1        LCD_SetCursor(Line,Column);
 193   1        for(i=Length;i>0;i--)
 194   1        {
 195   2          SingleNumber=Number/LCD_Pow(16,i-1)%16;
 196   2          if(SingleNumber<10)
 197   2          {
 198   3            LCD_WriteData(SingleNumber+'0');
 199   3          }
 200   2          else
 201   2          {
 202   3            LCD_WriteData(SingleNumber-10+'A');
 203   3          }
 204   2        }
 205   1      }
 206          
 207          /**
 208            * @brief  在LCD1602指定位置开始以二进制显示所给数字
 209            * @param  Line 起始行位置，范围：1~2
 210            * @param  Column 起始列位置，范围：1~16
 211            * @param  Number 要显示的数字，范围：0~1111 1111 1111 1111
 212            * @param  Length 要显示数字的长度，范围：1~16
 213            * @retval 无
 214            */
 215          void LCD_ShowBinNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length)
 216          {
 217   1        unsigned char i;
 218   1        LCD_SetCursor(Line,Column);
 219   1        for(i=Length;i>0;i--)
 220   1        {
 221   2          LCD_WriteData(Number/LCD_Pow(2,i-1)%2+'0');
 222   2        }
 223   1      }
 224          
 225          
 226          void Delay(unsigned int xms)  //@12MHz
 227          {
 228   1        unsigned char data i, j;
 229   1      
 230   1        while(xms--)
 231   1        {
 232   2          i = 2;
 233   2          j = 239;
 234   2          do 
 235   2          {
 236   3            while (--j);
 237   3          } while (--i);
 238   2          }
 239   1      }
 240          
C51 COMPILER V9.59.0.0   DALYA                                                             11/13/2024 14:57:20 PAGE 5   

 241          
 242          void NixieTube(unsigned char Location,Number)
 243          {
 244   1        unsigned char NixieTable[]={0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F};
 245   1        switch(Location)
 246   1        {
 247   2          case 1:P2_4=1;P2_3=1;P2_2=1;break;
 248   2          case 2:P2_4=1;P2_3=1;P2_2=0;break;
 249   2          case 3:P2_4=1;P2_3=0;P2_2=1;break;
 250   2          case 4:P2_4=1;P2_3=0;P2_2=0;break;
 251   2          case 5:P2_4=0;P2_3=1;P2_2=1;break;
 252   2          case 6:P2_4=0;P2_3=1;P2_2=0;break;
 253   2          case 7:P2_4=0;P2_3=0;P2_2=1;break;
 254   2          case 8:P2_4=0;P2_3=0;P2_2=0;break;
 255   2        }
 256   1        P0=NixieTable[Number];
 257   1        Delay(1);
 258   1        P0=0x00;
 259   1      }
 260          
 261          //作用是获取矩阵键盘，范围为0~16，无按键按下返回值为0
 262          unsigned char MatrixKeyboard()
 263          {
 264   1        unsigned char KeyNumber=0;
 265   1        
 266   1        P1=0xFF;
 267   1        P1_3=0;/*结合电路原理图，当P1_3=0，其他列为1时，则检测第1列，当有按键按下时，
 268   1              比如S1被按下，那么电路导通，会使得P1_7=0;反之，若P1_7=0,则S1被按下，
 269   1              所以我们依次判断对应4个IO口是否为0就可以知道哪个按键被按下了，
 270   1              然后依次切换对应列，逐个扫描就能识别整个矩阵键盘哪个按键被按下了。*/
 271   1        if(P1_7==0){Delay(100);while(P1_7==0);Delay(100);KeyNumber=1;}
 272   1        if(P1_6==0){Delay(100);while(P1_7==0);Delay(100);KeyNumber=5;}
 273   1        if(P1_5==0){Delay(100);while(P1_7==0);Delay(100);KeyNumber=9;}
 274   1        if(P1_4==0){Delay(100);while(P1_7==0);Delay(100);KeyNumber=13;}
 275   1        
 276   1        P1=0xFF;
 277   1        P1_2=0;
 278   1        if(P1_7==0){Delay(100);while(P1_7==0);Delay(100);KeyNumber=2;}
 279   1        if(P1_6==0){Delay(100);while(P1_7==0);Delay(100);KeyNumber=6;}
 280   1        if(P1_5==0){Delay(100);while(P1_7==0);Delay(100);KeyNumber=10;}
 281   1        if(P1_4==0){Delay(100);while(P1_7==0);Delay(100);KeyNumber=14;}
 282   1        
 283   1        P1=0xFF;
 284   1        P1_1=0;
 285   1        if(P1_7==0){Delay(100);while(P1_7==0);Delay(100);KeyNumber=3;}
 286   1        if(P1_6==0){Delay(100);while(P1_7==0);Delay(100);KeyNumber=7;}
 287   1        if(P1_5==0){Delay(100);while(P1_7==0);Delay(100);KeyNumber=11;}
 288   1        if(P1_4==0){Delay(100);while(P1_7==0);Delay(100);KeyNumber=15;}
 289   1        
 290   1        P1=0xFF;
 291   1        P1_0=0;
 292   1        if(P1_7==0){Delay(100);while(P1_7==0);Delay(100);KeyNumber=4;}
 293   1        if(P1_6==0){Delay(100);while(P1_7==0);Delay(100);KeyNumber=8;}
 294   1        if(P1_5==0){Delay(100);while(P1_7==0);Delay(100);KeyNumber=12;}
 295   1        if(P1_4==0){Delay(100);while(P1_7==0);Delay(100);KeyNumber=16;}
 296   1        
 297   1        return KeyNumber;
 298   1      }
 299          
 300          void Timer0Init() //1ms@12MHz
 301          {
 302   1        TMOD &= 0xF0;//把TMOD的低四位清零，高四位保持不变
C51 COMPILER V9.59.0.0   DALYA                                                             11/13/2024 14:57:20 PAGE 6   

 303   1        TMOD |= 0x01;//把TMOD的最低位置1，其他7位保持不变
 304   1        //这样做的好处就在于可以只操作TMOD的其中某些位而不影响其他位
 305   1        
 306   1        TF0=0;//设置T0定时器溢出标志位为0
 307   1        TR0=1;//即启动定时器开始计时
 308   1        
 309   1        TH0 = 0xFC;       //设置定时初始值为64535+1
 310   1        TL0 = 0x18;       
 311   1      //另一写法
 312   1      //  TH0=64535/256;//作用即得到64535转16进制后的高8位，这里除的结果只取整数，不取小数
 313   1      //                （结果即十进制的252，转16进制就是FC，刚好就是64535的十六进制高8位）
 314   1      //  TL0=64535%256+1;//结果即64535转16进制后的低8位（同理，自己计算），+1是因为定时器
 315   1      //最大定时为65535，而定时器要到65536才溢出，所以64535到65536是1001，多了1微秒，这样定时就是1.001ms
 316   1      
 317   1        ET0=1;//T0对应的中断开关闭合
 318   1        EA=1;//中断总开关闭合
 319   1        PT0=0;//设置中断优先级为低级
 320   1      }
 321          
 322          /*上面的的定时器初值程序要配合下面的定时器中断程序模板，只不过中断程序要写到主函数文件与主函数配合
 323          void Timer0_Routine() interrupt 1 //定时器T0的中断程序命名，这是标准定义，不能随意更改
 324          {
 325            static unsigned int T0Count;//静态变量使得该变量出了此函数仍然不会被销毁
 326            TH0=0xFC;//每次计时计完后需要重新赋初值，若
 327            TL0=0x18;//不赋初值，它会默认重0开始计时
 328            T0Count++;
 329            if(T0Count>=1000)
 330            {
 331              T0Count=0;
 332          
 333            }
 334          }
 335          */
 336          
 337          //作用是获取独立按键，范围为0~4，无按键按下返回值为0
 338          unsigned char IndependentKey()
 339          {
 340   1        unsigned char KeyNumber=0;
 341   1        
 342   1        if(P3_1==0){Delay(100);while(P3_1==0);Delay(100);KeyNumber=1;}
 343   1        if(P3_0==0){Delay(100);while(P3_0==0);Delay(100);KeyNumber=2;}
 344   1        if(P3_2==0){Delay(100);while(P3_2==0);Delay(100);KeyNumber=3;}
 345   1        if(P3_3==0){Delay(100);while(P3_3==0);Delay(100);KeyNumber=4;}  
 346   1        
 347   1        return KeyNumber;
 348   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    945    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      42
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
