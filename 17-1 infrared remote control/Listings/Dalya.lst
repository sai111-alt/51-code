C51 COMPILER V9.59.0.0   DALYA                                                             11/28/2024 11:35:39 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE DALYA
OBJECT MODULE PLACED IN .\Objects\Dalya.obj
COMPILER INVOKED BY: D:\RJ\Keil5\C51\BIN\C51.EXE Dalya.c OPTIMIZE(8,SPEED) BROWSE INCDIR(D:\RJ\Keil5\C51\INC;D:\RJ\Keil5
                    -\C51\INC\Atmel) DEBUG OBJECTEXTEND PRINT(.\Listings\Dalya.lst) TABS(2) OBJECT(.\Objects\Dalya.obj)

line level    source

   1          #include "Delay.h"
   2          
   3          // å‡½æ•°å®šä¹‰ï¼š
   4          /**
   5           * @brief  LCD1602å»¶æ—¶å‡½æ•°ï¼Œ12MHzè°ƒç”¨å¯å»¶æ—¶1ms
   6           * @param  æ— 
   7           * @retval æ— 
   8           */
   9          void LCD_Delay()
  10          {
  11   1        unsigned char i, j;
  12   1      
  13   1        i = 2;
  14   1        j = 239;
  15   1        do
  16   1        {
  17   2          while (--j)
  18   2            ;
  19   2        } while (--i);
  20   1      }
  21          
  22          /**
  23           * @brief  LCD1602å†™å‘½ä»¤
  24           * @param  Command è¦å†™å…¥çš„å‘½ä»¤
  25           * @retval æ— 
  26           */
  27          void LCD_WriteCommand(unsigned char Command)
  28          {
  29   1        LCD_RS = 0;
  30   1        LCD_RW = 0;
  31   1        LCD_DataPort = Command;
  32   1        LCD_EN = 1;
  33   1        LCD_Delay();
  34   1        LCD_EN = 0;
  35   1        LCD_Delay();
  36   1      }
  37          
  38          /**
  39           * @brief  LCD1602å†™æ•°æ®
  40           * @param  Data è¦å†™å…¥çš„æ•°æ®
  41           * @retval æ— 
  42           */
  43          void LCD_WriteData(unsigned char Data)
  44          {
  45   1        LCD_RS = 1;
  46   1        LCD_RW = 0;
  47   1        LCD_DataPort = Data;
  48   1        LCD_EN = 1;
  49   1        LCD_Delay();
  50   1        LCD_EN = 0;
  51   1        LCD_Delay();
  52   1      }
  53          
  54          /**
C51 COMPILER V9.59.0.0   DALYA                                                             11/28/2024 11:35:39 PAGE 2   

  55           * @brief  LCD1602è®¾ç½®å…‰æ ‡ä½ç½®
  56           * @param  Line è¡Œä½ç½®ï¼ŒèŒƒå›´ï¼š1~2
  57           * @param  Column åˆ—ä½ç½®ï¼ŒèŒƒå›´ï¼š1~16
  58           * @retval æ— 
  59           */
  60          void LCD_SetCursor(unsigned char Line, unsigned char Column)
  61          {
  62   1        if (Line == 1)
  63   1        {
  64   2          LCD_WriteCommand(0x80 | (Column - 1));
  65   2        }
  66   1        else if (Line == 2)
  67   1        {
  68   2          LCD_WriteCommand(0x80 | (Column - 1 + 0x40));
  69   2        }
  70   1      }
  71          
  72          /**
  73           * @brief  LCD1602åˆå§‹åŒ–å‡½æ•°
  74           * @param  æ— 
  75           * @retval æ— 
  76           */
  77          void LCD_Init()
  78          {
  79   1        LCD_WriteCommand(0x38); // å…«ä½æ•°æ®æ¥å£ï¼Œä¸¤è¡Œæ˜¾ç¤ºï¼Œ5*7ç‚¹é˜µ
  80   1        LCD_WriteCommand(0x0c); // æ˜¾ç¤ºå¼€ï¼Œå…‰æ ‡å…³ï¼Œé—ªçƒå…³
  81   1        LCD_WriteCommand(0x06); // æ•°æ®è¯»å†™æ“ä½œåï¼Œå…‰æ ‡è‡ªåŠ¨åŠ ä¸€ï¼Œç”»é¢ä¸åŠ¨
  82   1        LCD_WriteCommand(0x01); // å…‰æ ‡å¤ä½ï¼Œæ¸…å±
  83   1      }
  84          
  85          /**
  86           * @brief  åœ¨LCD1602æŒ‡å®šä½ç½®ä¸Šæ˜¾ç¤ºä¸€ä¸ªå­—ç¬¦
  87           * @param  Line è¡Œä½ç½®ï¼ŒèŒƒå›´ï¼š1~2
  88           * @param  Column åˆ—ä½ç½®ï¼ŒèŒƒå›´ï¼š1~16
  89           * @param  Char è¦æ˜¾ç¤ºçš„å­—ç¬¦
  90           * @retval æ— 
  91           */
  92          void LCD_ShowChar(unsigned char Line, unsigned char Column, char Char)
  93          {
  94   1        LCD_SetCursor(Line, Column);
  95   1        LCD_WriteData(Char);
  96   1      }
  97          
  98          /**
  99           * @brief  åœ¨LCD1602æŒ‡å®šä½ç½®å¼€å§‹æ˜¾ç¤ºæ‰€ç»™å­—ç¬¦ä¸²
 100           * @param  Line èµ·å§‹è¡Œä½ç½®ï¼ŒèŒƒå›´ï¼š1~2
 101           * @param  Column èµ·å§‹åˆ—ä½ç½®ï¼ŒèŒƒå›´ï¼š1~16
 102           * @param  String è¦æ˜¾ç¤ºçš„å­—ç¬¦ä¸²
 103           * @retval æ— 
 104           */
 105          void LCD_ShowString(unsigned char Line, unsigned char Column, char *String)
 106          {
 107   1        unsigned char i;
 108   1        LCD_SetCursor(Line, Column);
 109   1        for (i = 0; String[i] != '\0'; i++)
 110   1        {
 111   2          LCD_WriteData(String[i]);
 112   2        }
 113   1      }
 114          
 115          /**
 116           * @brief  è¿”å›å€¼=Xçš„Yæ¬¡æ–¹
C51 COMPILER V9.59.0.0   DALYA                                                             11/28/2024 11:35:39 PAGE 3   

 117           */
 118          int LCD_Pow(int X, int Y)
 119          {
 120   1        unsigned char i;
 121   1        int Result = 1;
 122   1        for (i = 0; i < Y; i++)
 123   1        {
 124   2          Result *= X;
 125   2        }
 126   1        return Result;
 127   1      }
 128          
 129          /**
 130           * @brief  åœ¨LCD1602æŒ‡å®šä½ç½®å¼€å§‹æ˜¾ç¤ºæ‰€ç»™æ•°å­—
 131           * @param  Line èµ·å§‹è¡Œä½ç½®ï¼ŒèŒƒå›´ï¼š1~2
 132           * @param  Column èµ·å§‹åˆ—ä½ç½®ï¼ŒèŒƒå›´ï¼š1~16
 133           * @param  Number è¦æ˜¾ç¤ºçš„æ•°å­—ï¼ŒèŒƒå›´ï¼š0~65535
 134           * @param  Length è¦æ˜¾ç¤ºæ•°å­—çš„é•¿åº¦ï¼ŒèŒƒå›´ï¼š1~5
 135           * @retval æ— 
 136           */
 137          void LCD_ShowNum(unsigned char Line, unsigned char Column, unsigned int Number, unsigned char Length)
 138          {
 139   1        unsigned char i;
 140   1        LCD_SetCursor(Line, Column);
 141   1        for (i = Length; i > 0; i--)
 142   1        {
 143   2          LCD_WriteData(Number / LCD_Pow(10, i - 1) % 10 + '0');
 144   2        }
 145   1      }
 146          
 147          /**
 148           * @brief  åœ¨LCD1602æŒ‡å®šä½ç½®å¼€å§‹ä»¥æœ‰ç¬¦å·åè¿›åˆ¶æ˜¾ç¤ºæ‰€ç»™æ•°å­—
 149           * @param  Line èµ·å§‹è¡Œä½ç½®ï¼ŒèŒƒå›´ï¼š1~2
 150           * @param  Column èµ·å§‹åˆ—ä½ç½®ï¼ŒèŒƒå›´ï¼š1~16
 151           * @param  Number è¦æ˜¾ç¤ºçš„æ•°å­—ï¼ŒèŒƒå›´ï¼š-32768~32767
 152           * @param  Length è¦æ˜¾ç¤ºæ•°å­—çš„é•¿åº¦ï¼ŒèŒƒå›´ï¼š1~5
 153           * @retval æ— 
 154           */
 155          void LCD_ShowSignedNum(unsigned char Line, unsigned char Column, int Number, unsigned char Length)
 156          {
 157   1        unsigned char i;
 158   1        unsigned int Number1;
 159   1        LCD_SetCursor(Line, Column);
 160   1        if (Number >= 0)
 161   1        {
 162   2          LCD_WriteData('+');
 163   2          Number1 = Number;
 164   2        }
 165   1        else
 166   1        {
 167   2          LCD_WriteData('-');
 168   2          Number1 = -Number;
 169   2        }
 170   1        for (i = Length; i > 0; i--)
 171   1        {
 172   2          LCD_WriteData(Number1 / LCD_Pow(10, i - 1) % 10 + '0');
 173   2        }
 174   1      }
 175          
 176          /**
 177           * @brief  åœ¨LCD1602æŒ‡å®šä½ç½®å¼€å§‹ä»¥åå…­è¿›åˆ¶æ˜¾ç¤ºæ‰€ç»™æ•°å­—
 178           * @param  Line èµ·å§‹è¡Œä½ç½®ï¼ŒèŒƒå›´ï¼š1~2
C51 COMPILER V9.59.0.0   DALYA                                                             11/28/2024 11:35:39 PAGE 4   

 179           * @param  Column èµ·å§‹åˆ—ä½ç½®ï¼ŒèŒƒå›´ï¼š1~16
 180           * @param  Number è¦æ˜¾ç¤ºçš„æ•°å­—ï¼ŒèŒƒå›´ï¼š0~0xFFFF
 181           * @param  Length è¦æ˜¾ç¤ºæ•°å­—çš„é•¿åº¦ï¼ŒèŒƒå›´ï¼š1~4
 182           * @retval æ— 
 183           */
 184          void LCD_ShowHexNum(unsigned char Line, unsigned char Column, unsigned int Number, unsigned char Length)
 185          {
 186   1        unsigned char i, SingleNumber;
 187   1        LCD_SetCursor(Line, Column);
 188   1        for (i = Length; i > 0; i--)
 189   1        {
 190   2          SingleNumber = Number / LCD_Pow(16, i - 1) % 16;
 191   2          if (SingleNumber < 10)
 192   2          {
 193   3            LCD_WriteData(SingleNumber + '0');
 194   3          }
 195   2          else
 196   2          {
 197   3            LCD_WriteData(SingleNumber - 10 + 'A');
 198   3          }
 199   2        }
 200   1      }
 201          
 202          /**
 203           * @brief  åœ¨LCD1602æŒ‡å®šä½ç½®å¼€å§‹ä»¥äºŒè¿›åˆ¶æ˜¾ç¤ºæ‰€ç»™æ•°å­—
 204           * @param  Line èµ·å§‹è¡Œä½ç½®ï¼ŒèŒƒå›´ï¼š1~2
 205           * @param  Column èµ·å§‹åˆ—ä½ç½®ï¼ŒèŒƒå›´ï¼š1~16
 206           * @param  Number è¦æ˜¾ç¤ºçš„æ•°å­—ï¼ŒèŒƒå›´ï¼š0~1111 1111 1111 1111
 207           * @param  Length è¦æ˜¾ç¤ºæ•°å­—çš„é•¿åº¦ï¼ŒèŒƒå›´ï¼š1~16
 208           * @retval æ— 
 209           */
 210          void LCD_ShowBinNum(unsigned char Line, unsigned char Column, unsigned int Number, unsigned char Length)
 211          {
 212   1        unsigned char i;
 213   1        LCD_SetCursor(Line, Column);
 214   1        for (i = Length; i > 0; i--)
 215   1        {
 216   2          LCD_WriteData(Number / LCD_Pow(2, i - 1) % 2 + '0');
 217   2        }
 218   1      }
 219          
 220          void Delay(unsigned int xms) //@12MHz
 221          {
 222   1        unsigned char data i, j;
 223   1      
 224   1        while (xms--)
 225   1        {
 226   2          i = 2;
 227   2          j = 239;
 228   2          do
 229   2          {
 230   3            while (--j)
 231   3              ;
 232   3          } while (--i);
 233   2        }
 234   1      }
 235          
 236          void NixieTube(unsigned char Location, unsigned char Number)
 237          {
 238   1        unsigned char NixieTable[] = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F};
 239   1        switch (Location)
 240   1        {
C51 COMPILER V9.59.0.0   DALYA                                                             11/28/2024 11:35:39 PAGE 5   

 241   2        case 1:
 242   2          P2_4 = 1;
 243   2          P2_3 = 1;
 244   2          P2_2 = 1;
 245   2          break;
 246   2        case 2:
 247   2          P2_4 = 1;
 248   2          P2_3 = 1;
 249   2          P2_2 = 0;
 250   2          break;
 251   2        case 3:
 252   2          P2_4 = 1;
 253   2          P2_3 = 0;
 254   2          P2_2 = 1;
 255   2          break;
 256   2        case 4:
 257   2          P2_4 = 1;
 258   2          P2_3 = 0;
 259   2          P2_2 = 0;
 260   2          break;
 261   2        case 5:
 262   2          P2_4 = 0;
 263   2          P2_3 = 1;
 264   2          P2_2 = 1;
 265   2          break;
 266   2        case 6:
 267   2          P2_4 = 0;
 268   2          P2_3 = 1;
 269   2          P2_2 = 0;
 270   2          break;
 271   2        case 7:
 272   2          P2_4 = 0;
 273   2          P2_3 = 0;
 274   2          P2_2 = 1;
 275   2          break;
 276   2        case 8:
 277   2          P2_4 = 0;
 278   2          P2_3 = 0;
 279   2          P2_2 = 0;
 280   2          break;
 281   2        }
 282   1        P0 = NixieTable[Number];
 283   1        // è¦åŒæ—¶æ˜¾ç¤ºå¤šä¸ªæ•°ç ç®¡ï¼Œéœ€è¦æ¶ˆå½±
 284   1        // æ˜¾ç¤ºå¤šä¸ªæ•°ç ç®¡ï¼šæ˜¯å…ˆè¿›è¡Œè¿™ä¸ªæ•°ç çš„ä½é€‰ï¼Œå†å¯¹å…¶æ®µé€‰
 285   1        // ç„¶åå†å¯¹ä¸‹ä¸€ä¸ªæ•°ç ç®¡è¿›è¡Œä½é€‰ï¼Œå†æ®µé€‰ï¼Œä¾æ¬¡ç±»æ¨
 286   1        // é€»è¾‘å°±æ˜¯ï¼šä½é€‰ æ®µé€‰ â†’ ä¸‹ä¸€ä¸ªæ•°ç ç®¡ä½é€‰ æ®µé€‰
 287   1        // è¿™æ®µé€‰åˆ°ä¸‹ä¸€ä¸ªä½é€‰ä¹‹é—´ï¼Œå› ä¸ºé€Ÿåº¦å¾ˆå¿«ï¼Œä¼šå¯¼è‡´ä¸Šä¸ªæ®µé€‰
 288   1        // çš„æ•°æ®ä¼šä¸²åˆ°ä¸‹ä¸€ä¸ªä½é€‰ä¸Šï¼Œä»è€Œäº§ç”Ÿå½±å­
 289   1        // æ‰€ä»¥æˆ‘ä»¬åœ¨è¿™ä¸ªé€»è¾‘ä¹‹é—´åŠ ä¸Šä¸€ä¸ªæ¸…é›¶å°±å¥½äº†ï¼Œè®©æ•°ç é¦†ä¸æ˜¾ç¤º
 290   1        // å³ï¼šä½é€‰ æ®µé€‰ æ¸…é›¶ ä¸‹ä¸€ä¸ªæ•°ç ç®¡ä½é€‰ æ®µé€‰
 291   1        // ä»¥ä¸‹ç¨‹åºç”¨äºæ•°ç ç®¡æ¶ˆå½±ï¼š
 292   1        Delay(1);  // å…ˆå»¶æ—¶1msï¼Œå¦‚æœç«‹é©¬æ¸…é›¶ï¼Œåªæ˜¯ä¼šè®©åŸæ¥çš„æ•°ç ç®¡å˜æš—
 293   1        P0 = 0x00; // æ¸…é›¶
 294   1      }
 295          
 296          // ä½œç”¨æ˜¯è·å–çŸ©é˜µé”®ç›˜ï¼ŒèŒƒå›´ä¸º0~16ï¼Œæ— æŒ‰é”®æŒ‰ä¸‹è¿”å›å€¼ä¸º0
 297          unsigned char MatrixKeyboard()
 298          {
 299   1        unsigned char KeyNumber = 0;
 300   1      
 301   1        P1 = 0xFF;
 302   1        P1_3 = 0; /*ç»“åˆç”µè·¯åŸç†å›¾ï¼Œå½“P1_3=0ï¼Œå…¶ä»–åˆ—ä¸º1æ—¶ï¼Œåˆ™æ£€æµ‹ç¬¬1åˆ—ï¼Œå½“æœ‰æŒ‰é”®æŒ‰ä¸‹æ
C51 COMPILER V9.59.0.0   DALYA                                                             11/28/2024 11:35:39 PAGE 6   

             -—¶ï¼Œ
 303   1                 æ¯”å¦‚S1è¢«æŒ‰ä¸‹ï¼Œé‚£ä¹ˆç”µè·¯å¯¼é€šï¼Œä¼šä½¿å¾—P1_7=0;åä¹‹ï¼Œè‹¥P1_7=0,åˆ™S1è¢«æŒ‰ä¸‹ï¼Œ
 304   1                 æ‰€ä»¥æˆ‘ä»¬ä¾æ¬¡åˆ¤æ–­å¯¹åº”4ä¸ªIOå£æ˜¯å¦ä¸º0å°±å¯ä»¥çŸ¥é“å“ªä¸ªæŒ‰é”®è¢«æŒ‰ä¸‹äº†ï¼Œ
 305   1                 ç„¶åä¾æ¬¡åˆ‡æ¢å¯¹åº”åˆ—ï¼Œé€ä¸ªæ‰«æå°±èƒ½è¯†åˆ«æ•´ä¸ªçŸ©é˜µé”®ç›˜å“ªä¸ªæŒ‰é”®è¢«æŒ‰ä¸‹äº†ã€‚
             -*/
 306   1        if (P1_7 == 0)
 307   1        {
 308   2          Delay(100);
 309   2          while (P1_7 == 0)
 310   2            ;
 311   2          Delay(100);
 312   2          KeyNumber = 1;
 313   2        }
 314   1        if (P1_6 == 0)
 315   1        {
 316   2          Delay(100);
 317   2          while (P1_7 == 0)
 318   2            ;
 319   2          Delay(100);
 320   2          KeyNumber = 5;
 321   2        }
 322   1        if (P1_5 == 0)
 323   1        {
 324   2          Delay(100);
 325   2          while (P1_7 == 0)
 326   2            ;
 327   2          Delay(100);
 328   2          KeyNumber = 9;
 329   2        }
 330   1        if (P1_4 == 0)
 331   1        {
 332   2          Delay(100);
 333   2          while (P1_7 == 0)
 334   2            ;
 335   2          Delay(100);
 336   2          KeyNumber = 13;
 337   2        }
 338   1      
 339   1        P1 = 0xFF;
 340   1        P1_2 = 0;
 341   1        if (P1_7 == 0)
 342   1        {
 343   2          Delay(100);
 344   2          while (P1_7 == 0)
 345   2            ;
 346   2          Delay(100);
 347   2          KeyNumber = 2;
 348   2        }
 349   1        if (P1_6 == 0)
 350   1        {
 351   2          Delay(100);
 352   2          while (P1_7 == 0)
 353   2            ;
 354   2          Delay(100);
 355   2          KeyNumber = 6;
 356   2        }
 357   1        if (P1_5 == 0)
 358   1        {
 359   2          Delay(100);
 360   2          while (P1_7 == 0)
 361   2            ;
 362   2          Delay(100);
C51 COMPILER V9.59.0.0   DALYA                                                             11/28/2024 11:35:39 PAGE 7   

 363   2          KeyNumber = 10;
 364   2        }
 365   1        if (P1_4 == 0)
 366   1        {
 367   2          Delay(100);
 368   2          while (P1_7 == 0)
 369   2            ;
 370   2          Delay(100);
 371   2          KeyNumber = 14;
 372   2        }
 373   1      
 374   1        P1 = 0xFF;
 375   1        P1_1 = 0;
 376   1        if (P1_7 == 0)
 377   1        {
 378   2          Delay(100);
 379   2          while (P1_7 == 0)
 380   2            ;
 381   2          Delay(100);
 382   2          KeyNumber = 3;
 383   2        }
 384   1        if (P1_6 == 0)
 385   1        {
 386   2          Delay(100);
 387   2          while (P1_7 == 0)
 388   2            ;
 389   2          Delay(100);
 390   2          KeyNumber = 7;
 391   2        }
 392   1        if (P1_5 == 0)
 393   1        {
 394   2          Delay(100);
 395   2          while (P1_7 == 0)
 396   2            ;
 397   2          Delay(100);
 398   2          KeyNumber = 11;
 399   2        }
 400   1        if (P1_4 == 0)
 401   1        {
 402   2          Delay(100);
 403   2          while (P1_7 == 0)
 404   2            ;
 405   2          Delay(100);
 406   2          KeyNumber = 15;
 407   2        }
 408   1      
 409   1        P1 = 0xFF;
 410   1        P1_0 = 0;
 411   1        if (P1_7 == 0)
 412   1        {
 413   2          Delay(100);
 414   2          while (P1_7 == 0)
 415   2            ;
 416   2          Delay(100);
 417   2          KeyNumber = 4;
 418   2        }
 419   1        if (P1_6 == 0)
 420   1        {
 421   2          Delay(100);
 422   2          while (P1_7 == 0)
 423   2            ;
 424   2          Delay(100);
C51 COMPILER V9.59.0.0   DALYA                                                             11/28/2024 11:35:39 PAGE 8   

 425   2          KeyNumber = 8;
 426   2        }
 427   1        if (P1_5 == 0)
 428   1        {
 429   2          Delay(100);
 430   2          while (P1_7 == 0)
 431   2            ;
 432   2          Delay(100);
 433   2          KeyNumber = 12;
 434   2        }
 435   1        if (P1_4 == 0)
 436   1        {
 437   2          Delay(100);
 438   2          while (P1_7 == 0)
 439   2            ;
 440   2          Delay(100);
 441   2          KeyNumber = 16;
 442   2        }
 443   1      
 444   1        return KeyNumber;
 445   1      }
 446          
 447          void Timer0Init() // 1ms@12MHz
 448          {
 449   1        TMOD &= 0xF0; // æŠŠTMODçš„ä½å››ä½æ¸…é›¶ï¼Œé«˜å››ä½ä¿æŒä¸å˜
 450   1        TMOD |= 0x01; // æŠŠTMODçš„æœ€ä½ä½ç½®1ï¼Œå…¶ä»–7ä½ä¿æŒä¸å˜ï¼Œè¿™é‡Œå³è®¾ç½®äº†å®šæ—¶å™¨0çš„æ¨¡å¼
             -æ˜¯å·¥ä½œæ–¹å¼1ï¼š16ä¸ºè®¡æ•°å™¨
 451   1        // è¿™æ ·åšçš„å¥½å¤„å°±åœ¨äºå¯ä»¥åªæ“ä½œTMODçš„å…¶ä¸­æŸäº›ä½è€Œä¸å½±å“å…¶ä»–ä½
 452   1      
 453   1        TF0 = 0; // è®¾ç½®T0å®šæ—¶å™¨æº¢å‡ºæ ‡å¿—ä½ä¸º0
 454   1        TR0 = 1; // å³å¯åŠ¨å®šæ—¶å™¨0å¼€å§‹è®¡æ—¶
 455   1      
 456   1        TH0 = 0xFC; // è®¾ç½®å®šæ—¶åˆå§‹å€¼ä¸º64535+1
 457   1        TL0 = 0x18;
 458   1        // å¦ä¸€å†™æ³•
 459   1        //  TH0=64535/256;//ä½œç”¨å³å¾—åˆ°64535è½¬16è¿›åˆ¶åçš„é«˜8ä½ï¼Œè¿™é‡Œé™¤çš„ç»“æœåªå–æ•´æ•°ï¼Œä¸å–
             -å°æ•°
 460   1        //                ï¼ˆç»“æœå³åè¿›åˆ¶çš„252ï¼Œè½¬16è¿›åˆ¶å°±æ˜¯FCï¼Œåˆšå¥½å°±æ˜¯64535çš„åå…­è¿›åˆ¶é«˜8ä½ï¼‰
 461   1        //  TL0=64535%256+1;//ç»“æœå³64535è½¬16è¿›åˆ¶åçš„ä½8ä½ï¼ˆåŒç†ï¼Œè‡ªå·±è®¡ç®—ï¼‰ï¼Œ+1æ˜¯å› ä¸ºå®šæ—
             -¶å™¨
 462   1        // æœ€å¤§å®šæ—¶ä¸º65535ï¼Œè€Œå®šæ—¶å™¨è¦åˆ°65536æ‰æº¢å‡ºï¼Œæ‰€ä»¥64535åˆ°65536æ˜¯1001ï¼Œå¤šäº†1å¾®ç§’ï¼
             -Œè¿™æ ·å®šæ—¶å°±æ˜¯1.001ms
 463   1      
 464   1        ET0 = 1; // T0å¯¹åº”çš„ä¸­æ–­å¼€å…³é—­åˆ
 465   1        EA = 1;  // ä¸­æ–­æ€»å¼€å…³é—­åˆ
 466   1        PT0 = 0; // è®¾ç½®ä¸­æ–­ä¼˜å…ˆçº§ä¸ºä½çº§
 467   1      }
 468          
 469          /*ä¸Šé¢çš„çš„å®šæ—¶å™¨åˆå§‹åŒ–ç¨‹åºè¦é…åˆä¸‹é¢çš„å®šæ—¶å™¨ä¸­æ–­ç¨‹åºæ¨¡æ¿ï¼Œåªä¸è¿‡ä¸­æ–­ç¨‹åº
             -è¦å†™åˆ°ä¸»å‡½æ•°æ–‡ä»¶ä¸ä¸»å‡½æ•°é…åˆ
 470          void Timer0_Routine() interrupt 1 //å®šæ—¶å™¨T0çš„ä¸­æ–­ç¨‹åºå‡½æ•°å‘½åéšæ„ï¼Œinterrupt 1ç”¨äºå°†æ­¤
             -å‡½æ•°å®šä¹‰ä¸ºå®šæ—¶å™¨0çš„ä¸­æ–­ç¨‹åº
 471          {
 472            static unsigned int T0Count;//é™æ€å˜é‡ä½¿å¾—è¯¥å˜é‡å‡ºäº†æ­¤å‡½æ•°ä»ç„¶ä¸ä¼šè¢«é”€æ¯
 473            TH0=0xFC;//æ¯æ¬¡è®¡æ—¶è®¡å®Œåéœ€è¦é‡æ–°èµ‹åˆå€¼ï¼Œè‹¥
 474            TL0=0x18;//ä¸èµ‹åˆå€¼ï¼Œå®ƒä¼šé»˜è®¤é‡0å¼€å§‹è®¡æ—¶,è¿™é‡Œè®¾ç½®çš„æ—¶æ¯éš”1msæ‰§è¡Œä¸€æ¬¡ä¸­æ–­
 475            T0Count++;
 476            if(T0Count>=1000)
 477            {
 478              T0Count=0;
 479          
 480            }
C51 COMPILER V9.59.0.0   DALYA                                                             11/28/2024 11:35:39 PAGE 9   

 481          }
 482          */
 483          
 484          // ä½œç”¨æ˜¯è·å–ç‹¬ç«‹æŒ‰é”®ï¼ŒèŒƒå›´ä¸º0~4ï¼Œæ— æŒ‰é”®æŒ‰ä¸‹è¿”å›å€¼ä¸º0
 485          unsigned char IndependentKey()
 486          {
 487   1        unsigned char KeyNumber = 0;
 488   1      
 489   1        if (P3_1 == 0)
 490   1        {
 491   2          Delay(100);
 492   2          while (P3_1 == 0)
 493   2            ;
 494   2          Delay(100);
 495   2          KeyNumber = 1;
 496   2        }
 497   1        if (P3_0 == 0)
 498   1        {
 499   2          Delay(100);
 500   2          while (P3_0 == 0)
 501   2            ;
 502   2          Delay(100);
 503   2          KeyNumber = 2;
 504   2        }
 505   1        if (P3_2 == 0)
 506   1        {
 507   2          Delay(100);
 508   2          while (P3_2 == 0)
 509   2            ;
 510   2          Delay(100);
 511   2          KeyNumber = 3;
 512   2        }
 513   1        if (P3_3 == 0)
 514   1        {
 515   2          Delay(100);
 516   2          while (P3_3 == 0)
 517   2            ;
 518   2          Delay(100);
 519   2          KeyNumber = 4;
 520   2        }
 521   1      
 522   1        return KeyNumber;
 523   1      }
 524          
 525          void UART_Init() // æ³¢ç‰¹ç‡4800
 526          {
 527   1        SCON = 0x50;  // å…¶ä»–åˆå§‹åŒ–ä¸º0ï¼Œè€Œé€‰æ‹©å·¥ä½œæ–¹å¼ä¸º1ä¸”RENç½®ä¸º1å…è®¸ä¸²å£æ¥å—æ•°æ®
 528   1        PCON |= 0x80; // ä½¿èƒ½æ³¢ç‰¹ç‡åŠ å€ï¼Œä»è€Œå‡å°‘è¯¯å·®
 529   1        // æ³¨æ„51çš„ä¸²å£åªèƒ½é…ç½®å®šæ—¶å™¨1
 530   1        TMOD &= 0x0F;
 531   1        TMOD |= 0x20; // ä¸²å£éœ€è¦å®šæ—¶å™¨1è®¾ç½®ä¸º8ä½è‡ªåŠ¨é‡è£…æ¨¡å¼
 532   1        // 8ä½è‡ªåŠ¨é‡è£…æ¨¡å¼å°±æ˜¯åªèµ‹ä¸€æ¬¡åˆå€¼ï¼Œåé¢è‡ªåŠ¨è£…è½½ï¼Œè€Œæ— éœ€å†ä¸­æ–­ç¨‹åºä¸­å†è£
             -…åˆå€¼
 533   1      
 534   1        // è¿™é‡Œæ— éœ€è®¾ç½®æº¢å‡ºæ ‡å¿—ä½ï¼Œå› ä¸ºåªè¦å®šæ—¶å™¨1åœ¨è®¡æ•°æœ‰æº¢å‡ºå°±ä¼šç”Ÿæˆæ³¢ç‰¹ç‡
 535   1        TR1 = 1; // å³å¯åŠ¨å®šæ—¶å™¨1å¼€å§‹è®¡æ—¶
 536   1      
 537   1        TH1 = 0xF4; // è®¾ç½®å®šæ—¶å™¨1åˆå€¼
 538   1        TL1 = 0xF4; // è®¾ç½®å®šæ—¶å™¨1çš„è‡ªåŠ¨é‡è½½å€¼
 539   1      
 540   1        ET1 = 0; // ç¦æ­¢å®šæ—¶å™¨ä¸­æ–­,è¿™é‡Œä¸éœ€è¦å®šæ—¶å™¨ä¸­æ–­
 541   1      
C51 COMPILER V9.59.0.0   DALYA                                                             11/28/2024 11:35:39 PAGE 10  

 542   1        EA = 1; // æ€»ä¸­æ–­å¼€å…³é—­åˆ
 543   1        ES = 1; // ä¸²å£ä¸­æ–­å¼€å…³é—­åˆï¼Œå½“å‘é€/æ¥å—æ•°æ®æ—¶ï¼Œåˆ™è§¦å‘ä¸­æ–­
 544   1      }
 545          
 546          void UART_SendByte(unsigned char Byte)
 547          {
 548   1        SBUF = Byte;  // SBUFè´Ÿè´£æ¥æ”¶/å‘é€æ•°æ®
 549   1        while (TI == 0) // TIæ˜¯å‘é€æ§åˆ¶å™¨ï¼Œå½“å‘é€å®ŒæˆåTI=0ï¼Œå¦åˆ™ä¸º1ï¼Œ
 550   1        {       // è¿™é‡Œä¸å¯ä»¥ä¸€ç›´å‘é€ï¼Œæ‰€ä»¥éœ€è¦çŸ¥é“TIå‘é€å®Œååæ‰èƒ½ç»§ç»­å‘é€
 551   2          ;
 552   2        }
 553   1        TI = 0; // TIä¸èƒ½è‡ªåŠ¨å¤ä½ï¼Œéœ€ç¨‹åºå¤ä½ï¼Œä»¥ä¾¿ä¸‹ä¸€æ¬¡çš„åˆ¤æ–­
 554   1      }
 555          
 556          /*ä¸­æ–­ç¨‹åºè¦å†™åˆ°ä¸»å‡½æ•°æ–‡ä»¶ä¸ä¸»å‡½æ•°é…åˆ,è¿™é‡Œçš„ä¸²å£ä¸­æ–­ç¨‹åºæ˜¯ç”¨äºç”µè„‘å‘é€ç
             -»™å•ç‰‡æœºæ•°æ®ï¼Œå•ç‰‡æœºåˆ™è§¦å‘ä¸­æ–­æ¥æ¥å—æ•°æ®
 557          void UART_Routine() interrupt 4 // interrupt 4ç”¨äºå°†æ­¤å‡½æ•°å®šä¹‰ä¸ºä¸²å£ä¸­æ–­çš„ç¨‹åº
 558          {
 559            if (RI == 1) // æ¥å—ä¸­æ–­è¯·æ±‚æ ‡å¿—ä½ï¼Œ1å³æ¥å—ï¼Œå› ä¸ºå‘é€å’Œæ¥å—ä¸­æ–­æ ‡å¿—ä½æ˜¯ç”¨çš„å
             -Œä¸€ä¸ªæˆ–é—¨ï¼Œ
 560            {      // æ‰€ä»¥è¿™é‡Œæˆ‘ä»¬éœ€è¦åˆ¤æ–­ç©¶ç«Ÿæ˜¯å‘é€è¿˜æ˜¯æ¥å—è§¦å‘çš„ä¸­æ–­
 561              ;
 562              RI = 0; // RIä¸èƒ½è‡ªåŠ¨å¤ä½ï¼Œéœ€ç¨‹åºå¤ä½ï¼Œä»¥ä¾¿ä¸‹ä¸€æ¬¡çš„åˆ¤æ–­
 563            }
 564          }
 565          */
 566          
 567          void MatrixLED_Init()
 568          {
 569   1        SCK = 0; // ç§»ä½ä¿¡å·åˆå§‹åŒ–ä¸º0ï¼Œæ–¹ä¾¿åç»­èµ‹1ç§»ä½
 570   1        RCK = 0; // å¹¶è¡Œè¾“å‡ºä¿¡å·åˆè¯•åŒ–ä¸º0, æ–¹ä¾¿åç»­è¾“å‡º
 571   1      }
 572          
 573          void _74HC595_WriteByte(unsigned char Byte) // æ³¨æ„å‡½æ•°åä¸èƒ½ä»¥æ•°å­—å¼€å¤´
 574          {
 575   1        unsigned char i = 0;
 576   1        for (i = 0; i < 8; i++)
 577   1        {
 578   2          SER = Byte & (0x80 >> i);
 579   2          // Byteä¸1000 0000ç›¸ä¸ç¡®è®¤Byteçš„æœ€é«˜ä½(åŒç†ï¼Œä¸‹æ¬¡å¾ªç¯ï¼ŒByteä¸0100 0000ç›¸ä¸)
 580   2          // è€ŒSERæ˜¯ä¸€ä¸ªä½ï¼Œç»™å®ƒèµ‹å€¼å°±æ˜¯é0å³1ï¼Œ
 581   2          // ä¹Ÿå°±æ˜¯è¯´SERåªè¦æ¥å—éé›¶çš„æ•°å€¼å®ƒå°±æ˜¯1ï¼Œå¦åˆ™å°±æ˜¯0
 582   2          // æ‰€ä»¥è¿™æ ·å°±å¯ä»¥æå–å‡ºByteçš„1ä½æ•°å€¼
 583   2          SCK = 1; // ç»™SCKèµ‹1ç§»ä½
 584   2          SCK = 0; // ç½®0æ–¹ä¾¿ä¸‹æ¬¡ç§»ä½
 585   2        }
 586   1        RCK = 1; // å°†æ­¤8ä½æ•°æ®è¾“å‡ºå‡ºå»
 587   1        RCK = 0; // ç½®0ä»¥ä¾¿ä¸‹æ¬¡è¾“å‡º
 588   1      }
 589          
 590          // Column å³çŸ©é˜µçš„åˆ—ï¼ŒData å³åˆ—æ˜¾ç¤ºçš„æ•°æ®ï¼Œé«˜ä½åœ¨ä¸Šï¼Œ1äº®0ç­
 591          void MatrixLED_Show(unsigned char Column, unsigned char Data)
 592          {
 593   1        _74HC595_WriteByte(Data);
 594   1        P0 = ~(0x80 >> Column);
 595   1        Delay(1); // ä¸æ•°ç ç®¡ä¸€æ ·ï¼Œè¿™é‡ŒLEDç‚¹é˜µä¹Ÿè¦æ¶ˆå½±
 596   1        P0 = 0xFF;
 597   1      }
 598          
 599          void DS1302_Init(void)
 600          {
 601   1        DS1302_SCLK = 0;
C51 COMPILER V9.59.0.0   DALYA                                                             11/28/2024 11:35:39 PAGE 11  

 602   1        DS1302_CE = 0;
 603   1      }
 604          
 605          void DS1302_WriteByte(unsigned char command, unsigned char Date)
 606          {
 607   1        unsigned char i;
 608   1        DS1302_CE = 1;
 609   1      
 610   1        for (i = 0; i < 8; i++)
 611   1        {
 612   2          DS1302_IO = command & (0x01 << i);
 613   2          DS1302_SCLK = 1;
 614   2          DS1302_SCLK = 0;
 615   2        }
 616   1      
 617   1        for (i = 0; i < 8; i++)
 618   1        {
 619   2          DS1302_IO = Date & (0x01 << i);
 620   2          DS1302_SCLK = 1;
 621   2          DS1302_SCLK = 0;
 622   2        }
 623   1        DS1302_CE = 0;
 624   1      }
 625          
 626          unsigned char DS1302_ReadByte(unsigned char command)
 627          {
 628   1        unsigned char i;
 629   1        unsigned char Data = 0x00;
 630   1        command |= 0x01; // è¿™ä¸€å¥çš„ä½œç”¨å°±åœ¨äºï¼Œç»™å‡½æ•°DS1302_ReadByteå†™çš„åœ°å€ï¼Œç„¶å
 631   1                 // æœ€åä¸€ä½ç½®1å°±æ˜¯å¯¹åº”è¯»çš„åœ°å€
 632   1      
 633   1        DS1302_CE = 1;
 634   1        for (i = 0; i < 8; i++)
 635   1        {
 636   2          DS1302_IO = command & (0x01 << i);
 637   2          DS1302_SCLK = 0;
 638   2          DS1302_SCLK = 1;
 639   2        }
 640   1      
 641   1        for (i = 0; i < 8; i++)
 642   1        {
 643   2          DS1302_SCLK = 1;
 644   2          DS1302_SCLK = 0;
 645   2          if (DS1302_IO)
 646   2          {
 647   3            Data |= (0x01 << i);
 648   3          }
 649   2        }
 650   1        DS1302_CE = 0;
 651   1        DS1302_IO = 0;
 652   1      
 653   1        return Data;
 654   1      }
 655          
 656          char DS1302_Time[7] = {23, 11, 19, 15, 41, 0, 6};
 657          
 658          void DS1302_SetTime(void)
 659          {
 660   1        DS1302_WriteByte(DS1302_WP, 0x00); // å…³é—­å†™ä¿æŠ¤
 661   1      
 662   1        DS1302_WriteByte(DS1302_YEAR, DS1302_Time[0] / 10 * 16 + DS1302_Time[0] % 10);
 663   1        DS1302_WriteByte(DS1302_MONTH, DS1302_Time[1] / 10 * 16 + DS1302_Time[1] % 10);
C51 COMPILER V9.59.0.0   DALYA                                                             11/28/2024 11:35:39 PAGE 12  

 664   1        DS1302_WriteByte(DS1302_DATE, DS1302_Time[2] / 10 * 16 + DS1302_Time[2] % 10);
 665   1        DS1302_WriteByte(DS1302_HOUR, DS1302_Time[3] / 10 * 16 + DS1302_Time[3] % 10);
 666   1        DS1302_WriteByte(DS1302_MINUTE, DS1302_Time[4] / 10 * 16 + DS1302_Time[4] % 10);
 667   1        DS1302_WriteByte(DS1302_SECOND, DS1302_Time[5] / 10 * 16 + DS1302_Time[5] % 10);
 668   1        DS1302_WriteByte(DS1302_DAY, DS1302_Time[6] / 10 * 16 + DS1302_Time[6] % 10);
 669   1      
 670   1        DS1302_WriteByte(DS1302_WP, 0x80); // æ‰“å¼€å†™ä¿æŠ¤
 671   1      }
 672          
 673          void DS1302_ReadTime(void)
 674          {
 675   1        unsigned char Temp; // ä¸­é—´å˜é‡
 676   1      
 677   1        Temp = DS1302_ReadByte(DS1302_YEAR);
 678   1        DS1302_Time[0] = Temp / 16 * 10 + Temp % 16;
 679   1        Temp = DS1302_ReadByte(DS1302_MONTH);
 680   1        DS1302_Time[1] = Temp / 16 * 10 + Temp % 16;
 681   1        Temp = DS1302_ReadByte(DS1302_DATE);
 682   1        DS1302_Time[2] = Temp / 16 * 10 + Temp % 16;
 683   1        Temp = DS1302_ReadByte(DS1302_HOUR);
 684   1        DS1302_Time[3] = Temp / 16 * 10 + Temp % 16;
 685   1        Temp = DS1302_ReadByte(DS1302_MINUTE);
 686   1        DS1302_Time[4] = Temp / 16 * 10 + Temp % 16;
 687   1        Temp = DS1302_ReadByte(DS1302_SECOND);
 688   1        DS1302_Time[5] = Temp / 16 * 10 + Temp % 16;
 689   1        Temp = DS1302_ReadByte(DS1302_DAY);
 690   1        DS1302_Time[6] = Temp / 16 * 10 + Temp % 16;
 691   1      }
 692          
 693          void I2C_Start(void) // I2Cå¼€å§‹
 694          {
 695   1        I2C_SCL = 1;
 696   1        I2C_SDA = 1;
 697   1        I2C_SDA = 0;
 698   1        I2C_SCL = 0;
 699   1      }
 700          
 701          void I2C_Stop(void) // I2Cåœæ­¢
 702          {
 703   1        I2C_SDA = 0;
 704   1        I2C_SCL = 1;
 705   1        I2C_SDA = 1;
 706   1      }
 707          
 708          void I2C_SendByte(unsigned char Byte) // I2Cå‘é€ä¸€ä¸ªå­—èŠ‚ï¼ŒByteå³è¦å‘é€çš„å­—èŠ‚
 709          {
 710   1        unsigned char i;
 711   1        for (i = 0; i < 8; i++)
 712   1        {
 713   2          I2C_SDA = Byte & (0x80 >> i); // ä¾æ¬¡å–å‡ºByteçš„ä½
 714   2          I2C_SCL = 1;
 715   2          I2C_SCL = 0;
 716   2        }
 717   1      }
 718          
 719          unsigned char I2C_ReceiveByte(void) // I2Cæ¥æ”¶ä¸€ä¸ªå­—èŠ‚å¹¶è¿”å›
 720          {
 721   1        unsigned char Byte = 0x00;
 722   1        unsigned char i = 0;
 723   1      
 724   1        I2C_SDA = 1;
 725   1      
C51 COMPILER V9.59.0.0   DALYA                                                             11/28/2024 11:35:39 PAGE 13  

 726   1        for (i = 0; i < 8; i++)
 727   1        {
 728   2          I2C_SCL = 1;
 729   2          if (I2C_SDA)
 730   2          {
 731   3            Byte |= (0x80 >> i);
 732   3          }
 733   2          I2C_SCL = 0;
 734   2        }
 735   1      
 736   1        return Byte;
 737   1      }
 738          
 739          void I2C_SendAck(unsigned char AckBit) // I2Cä¸»æœºå‘é€åº”ç­”ï¼ŒAckBitä¸ºåº”ç­”ï¼Œ0åº”ç­”ï¼Œ1éåº”ç­”
 740          {
 741   1        I2C_SDA = AckBit;
 742   1        I2C_SCL = 1;
 743   1        I2C_SCL = 0;
 744   1      }
 745          
 746          unsigned char I2C_ReceiveAck(void) // I2Cä¸»æœºæ¥æ”¶åº”ç­”
 747          {
 748   1        unsigned char AckBit;
 749   1        I2C_SDA = 1;
 750   1        I2C_SCL = 1;
 751   1        AckBit = I2C_SDA;
 752   1        I2C_SCL = 0;
 753   1        return AckBit;
 754   1      }
 755          
 756          // æ³¨æ„è¾“å…¥çš„WordAddressæ˜¯8ä½åœ°å€ï¼Œæ‰€ä»¥å–å€¼åº”æ˜¯0~255
 757          void AT24C02_WriterByte(unsigned char WordAddress, unsigned char Data)
 758          {
 759   1        I2C_Start();
 760   1        I2C_SendByte(AT24C02_ADDRESS);
 761   1        I2C_ReceiveAck();
 762   1        I2C_SendByte(WordAddress);
 763   1        I2C_ReceiveAck();
 764   1        I2C_SendByte(Data);
 765   1        I2C_ReceiveAck();
 766   1        I2C_Stop();
 767   1      }
 768          
 769          // æ³¨æ„è¾“å…¥çš„WordAddressæ˜¯8ä½åœ°å€ï¼Œæ‰€ä»¥å–å€¼åº”æ˜¯0~255
 770          unsigned char AT24C02_ReadByte(unsigned char WordAddress)
 771          {
 772   1        unsigned char Data = 0;
 773   1        I2C_Start();
 774   1        I2C_SendByte(AT24C02_ADDRESS);
 775   1        I2C_ReceiveAck();
 776   1        I2C_SendByte(WordAddress);
 777   1        I2C_ReceiveAck();
 778   1        I2C_Start();
 779   1        I2C_SendByte(AT24C02_ADDRESS | 0x01);
 780   1        I2C_ReceiveAck();
 781   1        Data = I2C_ReceiveByte();
 782   1        I2C_SendAck(1);
 783   1        I2C_Stop();
 784   1      
 785   1        return Data;
 786   1      }
 787          
C51 COMPILER V9.59.0.0   DALYA                                                             11/28/2024 11:35:39 PAGE 14  

 788          // å¤–éƒ¨ä¸­æ–­åˆå§‹åŒ–å‡½æ•°
 789          void Int0_Init(void)
 790          {
 791   1        IT0 = 1; // è®¾ç½®å¤–éƒ¨ä¸­æ–­ä¸ºä¸‹é™æ²¿è§¦å‘
 792   1        IE0 = 0; // è®¾ç½®å¤–éƒ¨ä¸­æ–­æ ‡å¿—ä½ä¸º0
 793   1        EX0 = 1; // å¤–éƒ¨ä¸­æ–­å¯¹åº”å¼€å…³é—­åˆ
 794   1        EA = 1;  // ä¸­æ–­æ€»å¼€å…³é—­åˆ
 795   1        PX0 = 1; // è®¾ç½®å¤–éƒ¨ä¸­æ–­çš„ä¼˜å…ˆçº§ä¸ºé«˜çº§ï¼Œè¿™æ ·å½“çº¢å¤–ä¿¡å·æ¥æ—¶ï¼Œå¤–éƒ¨ä¸­æ–­å¯ä»¥æ‰“
             -æ–­å…¶ä»–ä¿¡å·ä»¥å³æ—¶å¤„ç†çº¢å¤–ä¿¡å·
 796   1      }
 797          
 798          /*å¤–éƒ¨ä¸­æ–­å‡½æ•°æ¨¡æ¿
 799          void Int0_Routine(void) interrupt 0
 800          {
 801          
 802          }
 803          */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1849    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      7      41
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
