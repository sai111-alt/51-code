C51 COMPILER V9.59.0.0   DALYA                                                             12/01/2024 22:27:34 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE DALYA
OBJECT MODULE PLACED IN .\Objects\Dalya.obj
COMPILER INVOKED BY: D:\RJ\Keil5\C51\BIN\C51.EXE Dalya.c OPTIMIZE(8,SPEED) BROWSE INCDIR(D:\RJ\Keil5\C51\INC;D:\RJ\Keil5
                    -\C51\INC\Atmel) DEBUG OBJECTEXTEND PRINT(.\Listings\Dalya.lst) TABS(2) OBJECT(.\Objects\Dalya.obj)

line level    source

   1          #include "Delay.h"
   2          
   3          void Delay(unsigned int xms) //@12MHz
   4          {
   5   1        unsigned char data i, j;
   6   1      
   7   1        while (xms--)
   8   1        {
   9   2          i = 2;
  10   2          j = 239;
  11   2          do
  12   2          {
  13   3            while (--j)
  14   3              ;
  15   3          } while (--i);
  16   2        }
  17   1      }
  18          
  19          void NixieTube(unsigned char Location, unsigned char Number)
  20          {
  21   1        unsigned char NixieTable[] = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F};
  22   1        switch (Location)
  23   1        {
  24   2        case 1:
  25   2          P2_4 = 1;
  26   2          P2_3 = 1;
  27   2          P2_2 = 1;
  28   2          break;
  29   2        case 2:
  30   2          P2_4 = 1;
  31   2          P2_3 = 1;
  32   2          P2_2 = 0;
  33   2          break;
  34   2        case 3:
  35   2          P2_4 = 1;
  36   2          P2_3 = 0;
  37   2          P2_2 = 1;
  38   2          break;
  39   2        case 4:
  40   2          P2_4 = 1;
  41   2          P2_3 = 0;
  42   2          P2_2 = 0;
  43   2          break;
  44   2        case 5:
  45   2          P2_4 = 0;
  46   2          P2_3 = 1;
  47   2          P2_2 = 1;
  48   2          break;
  49   2        case 6:
  50   2          P2_4 = 0;
  51   2          P2_3 = 1;
  52   2          P2_2 = 0;
  53   2          break;
  54   2        case 7:
C51 COMPILER V9.59.0.0   DALYA                                                             12/01/2024 22:27:34 PAGE 2   

  55   2          P2_4 = 0;
  56   2          P2_3 = 0;
  57   2          P2_2 = 1;
  58   2          break;
  59   2        case 8:
  60   2          P2_4 = 0;
  61   2          P2_3 = 0;
  62   2          P2_2 = 0;
  63   2          break;
  64   2        }
  65   1        P0 = NixieTable[Number];
  66   1        // è¦åŒæ—¶æ˜¾ç¤ºå¤šä¸ªæ•°ç ç®¡ï¼Œéœ€è¦æ¶ˆå½±
  67   1        // æ˜¾ç¤ºå¤šä¸ªæ•°ç ç®¡ï¼šæ˜¯å…ˆè¿›è¡Œè¿™ä¸ªæ•°ç çš„ä½é€‰ï¼Œå†å¯¹å…¶æ®µé€‰
  68   1        // ç„¶åå†å¯¹ä¸‹ä¸€ä¸ªæ•°ç ç®¡è¿›è¡Œä½é€‰ï¼Œå†æ®µé€‰ï¼Œä¾æ¬¡ç±»æ¨
  69   1        // é€»è¾‘å°±æ˜¯ï¼šä½é€‰ æ®µé€‰ â†’ ä¸‹ä¸€ä¸ªæ•°ç ç®¡ä½é€‰ æ®µé€‰
  70   1        // è¿™æ®µé€‰åˆ°ä¸‹ä¸€ä¸ªä½é€‰ä¹‹é—´ï¼Œå› ä¸ºé€Ÿåº¦å¾ˆå¿«ï¼Œä¼šå¯¼è‡´ä¸Šä¸ªæ®µé€‰
  71   1        // çš„æ•°æ®ä¼šä¸²åˆ°ä¸‹ä¸€ä¸ªä½é€‰ä¸Šï¼Œä»è€Œäº§ç”Ÿå½±å­
  72   1        // æ‰€ä»¥æˆ‘ä»¬åœ¨è¿™ä¸ªé€»è¾‘ä¹‹é—´åŠ ä¸Šä¸€ä¸ªæ¸…é›¶å°±å¥½äº†ï¼Œè®©æ•°ç é¦†ä¸æ˜¾ç¤º
  73   1        // å³ï¼šä½é€‰ æ®µé€‰ æ¸…é›¶ ä¸‹ä¸€ä¸ªæ•°ç ç®¡ä½é€‰ æ®µé€‰
  74   1        // ä»¥ä¸‹ç¨‹åºç”¨äºæ•°ç ç®¡æ¶ˆå½±ï¼š
  75   1        Delay(1);  // å…ˆå»¶æ—¶1msï¼Œå¦‚æœç«‹é©¬æ¸…é›¶ï¼Œåªæ˜¯ä¼šè®©åŸæ¥çš„æ•°ç ç®¡å˜æš—
  76   1        P0 = 0x00; // æ¸…é›¶
  77   1      }
  78          
  79          // ä½œç”¨æ˜¯è·å–çŸ©é˜µé”®ç›˜ï¼ŒèŒƒå›´ä¸º0~16ï¼Œæ— æŒ‰é”®æŒ‰ä¸‹è¿”å›å€¼ä¸º0
  80          unsigned char MatrixKeyboard()
  81          {
  82   1        unsigned char KeyNumber = 0;
  83   1      
  84   1        P1 = 0xFF;
  85   1        P1_3 = 0; /*ç»“åˆç”µè·¯åŸç†å›¾ï¼Œå½“P1_3=0ï¼Œå…¶ä»–åˆ—ä¸º1æ—¶ï¼Œåˆ™æ£€æµ‹ç¬¬1åˆ—ï¼Œå½“æœ‰æŒ‰é”®æŒ‰ä¸‹æ
             -—¶ï¼Œ
  86   1                 æ¯”å¦‚S1è¢«æŒ‰ä¸‹ï¼Œé‚£ä¹ˆç”µè·¯å¯¼é€šï¼Œä¼šä½¿å¾—P1_7=0;åä¹‹ï¼Œè‹¥P1_7=0,åˆ™S1è¢«æŒ‰ä¸‹ï¼Œ
  87   1                 æ‰€ä»¥æˆ‘ä»¬ä¾æ¬¡åˆ¤æ–­å¯¹åº”4ä¸ªIOå£æ˜¯å¦ä¸º0å°±å¯ä»¥çŸ¥é“å“ªä¸ªæŒ‰é”®è¢«æŒ‰ä¸‹äº†ï¼Œ
  88   1                 ç„¶åä¾æ¬¡åˆ‡æ¢å¯¹åº”åˆ—ï¼Œé€ä¸ªæ‰«æå°±èƒ½è¯†åˆ«æ•´ä¸ªçŸ©é˜µé”®ç›˜å“ªä¸ªæŒ‰é”®è¢«æŒ‰ä¸‹äº†ã€‚
             -*/
  89   1        if (P1_7 == 0)
  90   1        {
  91   2          Delay(100);
  92   2          while (P1_7 == 0)
  93   2            ;
  94   2          Delay(100);
  95   2          KeyNumber = 1;
  96   2        }
  97   1        if (P1_6 == 0)
  98   1        {
  99   2          Delay(100);
 100   2          while (P1_7 == 0)
 101   2            ;
 102   2          Delay(100);
 103   2          KeyNumber = 5;
 104   2        }
 105   1        if (P1_5 == 0)
 106   1        {
 107   2          Delay(100);
 108   2          while (P1_7 == 0)
 109   2            ;
 110   2          Delay(100);
 111   2          KeyNumber = 9;
 112   2        }
 113   1        if (P1_4 == 0)
 114   1        {
C51 COMPILER V9.59.0.0   DALYA                                                             12/01/2024 22:27:34 PAGE 3   

 115   2          Delay(100);
 116   2          while (P1_7 == 0)
 117   2            ;
 118   2          Delay(100);
 119   2          KeyNumber = 13;
 120   2        }
 121   1      
 122   1        P1 = 0xFF;
 123   1        P1_2 = 0;
 124   1        if (P1_7 == 0)
 125   1        {
 126   2          Delay(100);
 127   2          while (P1_7 == 0)
 128   2            ;
 129   2          Delay(100);
 130   2          KeyNumber = 2;
 131   2        }
 132   1        if (P1_6 == 0)
 133   1        {
 134   2          Delay(100);
 135   2          while (P1_7 == 0)
 136   2            ;
 137   2          Delay(100);
 138   2          KeyNumber = 6;
 139   2        }
 140   1        if (P1_5 == 0)
 141   1        {
 142   2          Delay(100);
 143   2          while (P1_7 == 0)
 144   2            ;
 145   2          Delay(100);
 146   2          KeyNumber = 10;
 147   2        }
 148   1        if (P1_4 == 0)
 149   1        {
 150   2          Delay(100);
 151   2          while (P1_7 == 0)
 152   2            ;
 153   2          Delay(100);
 154   2          KeyNumber = 14;
 155   2        }
 156   1      
 157   1        P1 = 0xFF;
 158   1        P1_1 = 0;
 159   1        if (P1_7 == 0)
 160   1        {
 161   2          Delay(100);
 162   2          while (P1_7 == 0)
 163   2            ;
 164   2          Delay(100);
 165   2          KeyNumber = 3;
 166   2        }
 167   1        if (P1_6 == 0)
 168   1        {
 169   2          Delay(100);
 170   2          while (P1_7 == 0)
 171   2            ;
 172   2          Delay(100);
 173   2          KeyNumber = 7;
 174   2        }
 175   1        if (P1_5 == 0)
 176   1        {
C51 COMPILER V9.59.0.0   DALYA                                                             12/01/2024 22:27:34 PAGE 4   

 177   2          Delay(100);
 178   2          while (P1_7 == 0)
 179   2            ;
 180   2          Delay(100);
 181   2          KeyNumber = 11;
 182   2        }
 183   1        if (P1_4 == 0)
 184   1        {
 185   2          Delay(100);
 186   2          while (P1_7 == 0)
 187   2            ;
 188   2          Delay(100);
 189   2          KeyNumber = 15;
 190   2        }
 191   1      
 192   1        P1 = 0xFF;
 193   1        P1_0 = 0;
 194   1        if (P1_7 == 0)
 195   1        {
 196   2          Delay(100);
 197   2          while (P1_7 == 0)
 198   2            ;
 199   2          Delay(100);
 200   2          KeyNumber = 4;
 201   2        }
 202   1        if (P1_6 == 0)
 203   1        {
 204   2          Delay(100);
 205   2          while (P1_7 == 0)
 206   2            ;
 207   2          Delay(100);
 208   2          KeyNumber = 8;
 209   2        }
 210   1        if (P1_5 == 0)
 211   1        {
 212   2          Delay(100);
 213   2          while (P1_7 == 0)
 214   2            ;
 215   2          Delay(100);
 216   2          KeyNumber = 12;
 217   2        }
 218   1        if (P1_4 == 0)
 219   1        {
 220   2          Delay(100);
 221   2          while (P1_7 == 0)
 222   2            ;
 223   2          Delay(100);
 224   2          KeyNumber = 16;
 225   2        }
 226   1      
 227   1        return KeyNumber;
 228   1      }
 229          
 230          void Timer0Init() // 1ms@12MHz
 231          {
 232   1        TMOD &= 0xF0; // æŠŠTMODçš„ä½å››ä½æ¸…é›¶ï¼Œé«˜å››ä½ä¿æŒä¸å˜
 233   1        TMOD |= 0x01; // æŠŠTMODçš„æœ€ä½ä½ç½®1ï¼Œå…¶ä»–7ä½ä¿æŒä¸å˜ï¼Œè¿™é‡Œå³è®¾ç½®äº†å®šæ—¶å™¨0çš„æ¨¡å¼
             -æ˜¯å·¥ä½œæ–¹å¼1ï¼š16ä½è®¡æ•°å™¨
 234   1        // è¿™æ ·åšçš„å¥½å¤„å°±åœ¨äºå¯ä»¥åªæ“ä½œTMODçš„å…¶ä¸­æŸäº›ä½è€Œä¸å½±å“å…¶ä»–ä½
 235   1      
 236   1        TF0 = 0; // è®¾ç½®T0å®šæ—¶å™¨æº¢å‡ºæ ‡å¿—ä½ä¸º0
 237   1        TR0 = 1; // å³å¯åŠ¨å®šæ—¶å™¨0å¼€å§‹è®¡æ—¶
C51 COMPILER V9.59.0.0   DALYA                                                             12/01/2024 22:27:34 PAGE 5   

 238   1      
 239   1        TH0 = 0xFC; // è®¾ç½®å®šæ—¶åˆå§‹å€¼ä¸º64535+1
 240   1        TL0 = 0x18;
 241   1        // å¦ä¸€å†™æ³•
 242   1        //  TH0=64535/256;//ä½œç”¨å³å¾—åˆ°64535è½¬16è¿›åˆ¶åçš„é«˜8ä½ï¼Œè¿™é‡Œé™¤çš„ç»“æœåªå–æ•´æ•°ï¼Œä¸å–
             -å°æ•°
 243   1        //                ï¼ˆç»“æœå³åè¿›åˆ¶çš„252ï¼Œè½¬16è¿›åˆ¶å°±æ˜¯FCï¼Œåˆšå¥½å°±æ˜¯64535çš„åå…­è¿›åˆ¶é«˜8ä½ï¼‰
 244   1        //  TL0=64535%256+1;//ç»“æœå³64535è½¬16è¿›åˆ¶åçš„ä½8ä½ï¼ˆåŒç†ï¼Œè‡ªå·±è®¡ç®—ï¼‰ï¼Œ+1æ˜¯å› ä¸ºå®šæ—
             -¶å™¨
 245   1        // æœ€å¤§å®šæ—¶ä¸º65535ï¼Œè€Œå®šæ—¶å™¨è¦åˆ°65536æ‰æº¢å‡ºï¼Œæ‰€ä»¥64535åˆ°65536æ˜¯1001ï¼Œå¤šäº†1å¾®ç§’ï¼
             -Œè¿™æ ·å®šæ—¶å°±æ˜¯1.001ms
 246   1      
 247   1        ET0 = 1; // T0å¯¹åº”çš„ä¸­æ–­å¼€å…³é—­åˆ
 248   1        EA = 1;  // ä¸­æ–­æ€»å¼€å…³é—­åˆ
 249   1        PT0 = 0; // è®¾ç½®ä¸­æ–­ä¼˜å…ˆçº§ä¸ºä½çº§
 250   1      }
 251          
 252          /*ä¸Šé¢çš„çš„å®šæ—¶å™¨åˆå§‹åŒ–ç¨‹åºè¦é…åˆä¸‹é¢çš„å®šæ—¶å™¨ä¸­æ–­ç¨‹åºæ¨¡æ¿ï¼Œåªä¸è¿‡ä¸­æ–­ç¨‹åº
             -è¦å†™åˆ°ä¸»å‡½æ•°æ–‡ä»¶ä¸ä¸»å‡½æ•°é…åˆ
 253          void Timer0_Routine() interrupt 1 //å®šæ—¶å™¨T0çš„ä¸­æ–­ç¨‹åºå‡½æ•°å‘½åéšæ„ï¼Œinterrupt 1ç”¨äºå°†æ­¤
             -å‡½æ•°å®šä¹‰ä¸ºå®šæ—¶å™¨0çš„ä¸­æ–­ç¨‹åº
 254          {
 255            static unsigned int T0Count;//é™æ€å˜é‡ä½¿å¾—è¯¥å˜é‡å‡ºäº†æ­¤å‡½æ•°ä»ç„¶ä¸ä¼šè¢«é”€æ¯
 256            TH0=0xFC;//æ¯æ¬¡è®¡æ—¶è®¡å®Œåéœ€è¦é‡æ–°èµ‹åˆå€¼ï¼Œè‹¥
 257            TL0=0x18;//ä¸èµ‹åˆå€¼ï¼Œå®ƒä¼šé»˜è®¤é‡0å¼€å§‹è®¡æ—¶,è¿™é‡Œè®¾ç½®çš„æ—¶æ¯éš”1msæ‰§è¡Œä¸€æ¬¡ä¸­æ–­
 258            T0Count++;
 259            if(T0Count>=1000)
 260            {
 261              T0Count=0;
 262          
 263            }
 264          }
 265          */
 266          
 267          // ä½œç”¨æ˜¯è·å–ç‹¬ç«‹æŒ‰é”®ï¼ŒèŒƒå›´ä¸º0~4ï¼Œæ— æŒ‰é”®æŒ‰ä¸‹è¿”å›å€¼ä¸º0
 268          unsigned char IndependentKey()
 269          {
 270   1        unsigned char KeyNumber = 0;
 271   1      
 272   1        if (P3_1 == 0)
 273   1        {
 274   2          Delay(100);
 275   2          while (P3_1 == 0)
 276   2            ;
 277   2          Delay(100);
 278   2          KeyNumber = 1;
 279   2        }
 280   1        if (P3_0 == 0)
 281   1        {
 282   2          Delay(100);
 283   2          while (P3_0 == 0)
 284   2            ;
 285   2          Delay(100);
 286   2          KeyNumber = 2;
 287   2        }
 288   1        if (P3_2 == 0)
 289   1        {
 290   2          Delay(100);
 291   2          while (P3_2 == 0)
 292   2            ;
 293   2          Delay(100);
 294   2          KeyNumber = 3;
C51 COMPILER V9.59.0.0   DALYA                                                             12/01/2024 22:27:34 PAGE 6   

 295   2        }
 296   1        if (P3_3 == 0)
 297   1        {
 298   2          Delay(100);
 299   2          while (P3_3 == 0)
 300   2            ;
 301   2          Delay(100);
 302   2          KeyNumber = 4;
 303   2        }
 304   1      
 305   1        return KeyNumber;
 306   1      }
 307          
 308          void UART_Init() // æ³¢ç‰¹ç‡4800
 309          {
 310   1        SCON = 0x50;  // å…¶ä»–åˆå§‹åŒ–ä¸º0ï¼Œè€Œé€‰æ‹©å·¥ä½œæ–¹å¼ä¸º1ä¸”RENç½®ä¸º1å…è®¸ä¸²å£æ¥å—æ•°æ®
 311   1        PCON |= 0x80; // ä½¿èƒ½æ³¢ç‰¹ç‡åŠ å€ï¼Œä»è€Œå‡å°‘è¯¯å·®
 312   1        // æ³¨æ„51çš„ä¸²å£åªèƒ½é…ç½®å®šæ—¶å™¨1
 313   1        TMOD &= 0x0F;
 314   1        TMOD |= 0x20; // ä¸²å£éœ€è¦å®šæ—¶å™¨1è®¾ç½®ä¸º8ä½è‡ªåŠ¨é‡è£…æ¨¡å¼
 315   1        // 8ä½è‡ªåŠ¨é‡è£…æ¨¡å¼å°±æ˜¯åªèµ‹ä¸€æ¬¡åˆå€¼ï¼Œåé¢è‡ªåŠ¨è£…è½½ï¼Œè€Œæ— éœ€å†ä¸­æ–­ç¨‹åºä¸­å†è£
             -…åˆå€¼
 316   1      
 317   1        // è¿™é‡Œæ— éœ€è®¾ç½®æº¢å‡ºæ ‡å¿—ä½ï¼Œå› ä¸ºåªè¦å®šæ—¶å™¨1åœ¨è®¡æ•°æœ‰æº¢å‡ºå°±ä¼šç”Ÿæˆæ³¢ç‰¹ç‡
 318   1        TR1 = 1; // å³å¯åŠ¨å®šæ—¶å™¨1å¼€å§‹è®¡æ—¶
 319   1      
 320   1        TH1 = 0xF4; // è®¾ç½®å®šæ—¶å™¨1åˆå€¼
 321   1        TL1 = 0xF4; // è®¾ç½®å®šæ—¶å™¨1çš„è‡ªåŠ¨é‡è½½å€¼
 322   1      
 323   1        ET1 = 0; // ç¦æ­¢å®šæ—¶å™¨ä¸­æ–­,è¿™é‡Œä¸éœ€è¦å®šæ—¶å™¨ä¸­æ–­
 324   1      
 325   1        EA = 1; // æ€»ä¸­æ–­å¼€å…³é—­åˆ
 326   1        ES = 1; // ä¸²å£ä¸­æ–­å¼€å…³é—­åˆï¼Œå½“å‘é€/æ¥å—æ•°æ®æ—¶ï¼Œåˆ™è§¦å‘ä¸­æ–­
 327   1      }
 328          
 329          void UART_SendByte(unsigned char Byte)
 330          {
 331   1        SBUF = Byte;  // SBUFè´Ÿè´£æ¥æ”¶/å‘é€æ•°æ®
 332   1        while (TI == 0) // TIæ˜¯å‘é€æ§åˆ¶å™¨ï¼Œå½“å‘é€å®ŒæˆåTI=0ï¼Œå¦åˆ™ä¸º1ï¼Œ
 333   1        {       // è¿™é‡Œä¸å¯ä»¥ä¸€ç›´å‘é€ï¼Œæ‰€ä»¥éœ€è¦çŸ¥é“TIå‘é€å®Œååæ‰èƒ½ç»§ç»­å‘é€
 334   2          ;
 335   2        }
 336   1        TI = 0; // TIä¸èƒ½è‡ªåŠ¨å¤ä½ï¼Œéœ€ç¨‹åºå¤ä½ï¼Œä»¥ä¾¿ä¸‹ä¸€æ¬¡çš„åˆ¤æ–­
 337   1      }
 338          
 339          /*ä¸­æ–­ç¨‹åºè¦å†™åˆ°ä¸»å‡½æ•°æ–‡ä»¶ä¸ä¸»å‡½æ•°é…åˆ,è¿™é‡Œçš„ä¸²å£ä¸­æ–­ç¨‹åºæ˜¯ç”¨äºç”µè„‘å‘é€ç
             -»™å•ç‰‡æœºæ•°æ®ï¼Œå•ç‰‡æœºåˆ™è§¦å‘ä¸­æ–­æ¥æ¥å—æ•°æ®
 340          void UART_Routine() interrupt 4 // interrupt 4ç”¨äºå°†æ­¤å‡½æ•°å®šä¹‰ä¸ºä¸²å£ä¸­æ–­çš„ç¨‹åº
 341          {
 342            if (RI == 1) // æ¥å—ä¸­æ–­è¯·æ±‚æ ‡å¿—ä½ï¼Œ1å³æ¥å—ï¼Œå› ä¸ºå‘é€å’Œæ¥å—ä¸­æ–­æ ‡å¿—ä½æ˜¯ç”¨çš„å
             -Œä¸€ä¸ªæˆ–é—¨ï¼Œ
 343            {      // æ‰€ä»¥è¿™é‡Œæˆ‘ä»¬éœ€è¦åˆ¤æ–­ç©¶ç«Ÿæ˜¯å‘é€è¿˜æ˜¯æ¥å—è§¦å‘çš„ä¸­æ–­
 344              ;
 345              RI = 0; // RIä¸èƒ½è‡ªåŠ¨å¤ä½ï¼Œéœ€ç¨‹åºå¤ä½ï¼Œä»¥ä¾¿ä¸‹ä¸€æ¬¡çš„åˆ¤æ–­
 346            }
 347          }
 348          */
 349          
 350          void MatrixLED_Init()
 351          {
 352   1        SCK = 0; // ç§»ä½ä¿¡å·åˆå§‹åŒ–ä¸º0ï¼Œæ–¹ä¾¿åç»­èµ‹1ç§»ä½
 353   1        RCK = 0; // å¹¶è¡Œè¾“å‡ºä¿¡å·åˆè¯•åŒ–ä¸º0, æ–¹ä¾¿åç»­è¾“å‡º
C51 COMPILER V9.59.0.0   DALYA                                                             12/01/2024 22:27:34 PAGE 7   

 354   1      }
 355          
 356          void _74HC595_WriteByte(unsigned char Byte) // æ³¨æ„å‡½æ•°åä¸èƒ½ä»¥æ•°å­—å¼€å¤´
 357          {
 358   1        unsigned char i = 0;
 359   1        for (i = 0; i < 8; i++)
 360   1        {
 361   2          SER = Byte & (0x80 >> i);
 362   2          // Byteä¸1000 0000ç›¸ä¸ç¡®è®¤Byteçš„æœ€é«˜ä½(åŒç†ï¼Œä¸‹æ¬¡å¾ªç¯ï¼ŒByteä¸0100 0000ç›¸ä¸)
 363   2          // è€ŒSERæ˜¯ä¸€ä¸ªä½ï¼Œç»™å®ƒèµ‹å€¼å°±æ˜¯é0å³1ï¼Œ
 364   2          // ä¹Ÿå°±æ˜¯è¯´SERåªè¦æ¥å—éé›¶çš„æ•°å€¼å®ƒå°±æ˜¯1ï¼Œå¦åˆ™å°±æ˜¯0
 365   2          // æ‰€ä»¥è¿™æ ·å°±å¯ä»¥æå–å‡ºByteçš„1ä½æ•°å€¼
 366   2          SCK = 1; // ç»™SCKèµ‹1ç§»ä½
 367   2          SCK = 0; // ç½®0æ–¹ä¾¿ä¸‹æ¬¡ç§»ä½
 368   2        }
 369   1        RCK = 1; // å°†æ­¤8ä½æ•°æ®è¾“å‡ºå‡ºå»
 370   1        RCK = 0; // ç½®0ä»¥ä¾¿ä¸‹æ¬¡è¾“å‡º
 371   1      }
 372          
 373          // Column å³çŸ©é˜µçš„åˆ—ï¼ŒData å³åˆ—æ˜¾ç¤ºçš„æ•°æ®ï¼Œé«˜ä½åœ¨ä¸Šï¼Œ1äº®0ç­
 374          void MatrixLED_Show(unsigned char Column, unsigned char Data)
 375          {
 376   1        _74HC595_WriteByte(Data);
 377   1        P0 = ~(0x80 >> Column);
 378   1        Delay(1); // ä¸æ•°ç ç®¡ä¸€æ ·ï¼Œè¿™é‡ŒLEDç‚¹é˜µä¹Ÿè¦æ¶ˆå½±
 379   1        P0 = 0xFF;
 380   1      }
 381          
 382          void DS1302_Init(void)
 383          {
 384   1        DS1302_SCLK = 0;
 385   1        DS1302_CE = 0;
 386   1      }
 387          
 388          void DS1302_WriteByte(unsigned char command, unsigned char Date)
 389          {
 390   1        unsigned char i;
 391   1        DS1302_CE = 1;
 392   1      
 393   1        for (i = 0; i < 8; i++)
 394   1        {
 395   2          DS1302_IO = command & (0x01 << i);
 396   2          DS1302_SCLK = 1;
 397   2          DS1302_SCLK = 0;
 398   2        }
 399   1      
 400   1        for (i = 0; i < 8; i++)
 401   1        {
 402   2          DS1302_IO = Date & (0x01 << i);
 403   2          DS1302_SCLK = 1;
 404   2          DS1302_SCLK = 0;
 405   2        }
 406   1        DS1302_CE = 0;
 407   1      }
 408          
 409          unsigned char DS1302_ReadByte(unsigned char command)
 410          {
 411   1        unsigned char i;
 412   1        unsigned char Data = 0x00;
 413   1        command |= 0x01; // è¿™ä¸€å¥çš„ä½œç”¨å°±åœ¨äºï¼Œç»™å‡½æ•°DS1302_ReadByteå†™çš„åœ°å€ï¼Œç„¶å
 414   1                 // æœ€åä¸€ä½ç½®1å°±æ˜¯å¯¹åº”è¯»çš„åœ°å€
 415   1      
C51 COMPILER V9.59.0.0   DALYA                                                             12/01/2024 22:27:34 PAGE 8   

 416   1        DS1302_CE = 1;
 417   1        for (i = 0; i < 8; i++)
 418   1        {
 419   2          DS1302_IO = command & (0x01 << i);
 420   2          DS1302_SCLK = 0;
 421   2          DS1302_SCLK = 1;
 422   2        }
 423   1      
 424   1        for (i = 0; i < 8; i++)
 425   1        {
 426   2          DS1302_SCLK = 1;
 427   2          DS1302_SCLK = 0;
 428   2          if (DS1302_IO)
 429   2          {
 430   3            Data |= (0x01 << i);
 431   3          }
 432   2        }
 433   1        DS1302_CE = 0;
 434   1        DS1302_IO = 0;
 435   1      
 436   1        return Data;
 437   1      }
 438          
 439          char DS1302_Time[7] = {23, 11, 19, 15, 41, 0, 6};
 440          
 441          void DS1302_SetTime(void)
 442          {
 443   1        DS1302_WriteByte(DS1302_WP, 0x00); // å…³é—­å†™ä¿æŠ¤
 444   1      
 445   1        DS1302_WriteByte(DS1302_YEAR, DS1302_Time[0] / 10 * 16 + DS1302_Time[0] % 10);
 446   1        DS1302_WriteByte(DS1302_MONTH, DS1302_Time[1] / 10 * 16 + DS1302_Time[1] % 10);
 447   1        DS1302_WriteByte(DS1302_DATE, DS1302_Time[2] / 10 * 16 + DS1302_Time[2] % 10);
 448   1        DS1302_WriteByte(DS1302_HOUR, DS1302_Time[3] / 10 * 16 + DS1302_Time[3] % 10);
 449   1        DS1302_WriteByte(DS1302_MINUTE, DS1302_Time[4] / 10 * 16 + DS1302_Time[4] % 10);
 450   1        DS1302_WriteByte(DS1302_SECOND, DS1302_Time[5] / 10 * 16 + DS1302_Time[5] % 10);
 451   1        DS1302_WriteByte(DS1302_DAY, DS1302_Time[6] / 10 * 16 + DS1302_Time[6] % 10);
 452   1      
 453   1        DS1302_WriteByte(DS1302_WP, 0x80); // æ‰“å¼€å†™ä¿æŠ¤
 454   1      }
 455          
 456          void DS1302_ReadTime(void)
 457          {
 458   1        unsigned char Temp; // ä¸­é—´å˜é‡
 459   1      
 460   1        Temp = DS1302_ReadByte(DS1302_YEAR);
 461   1        DS1302_Time[0] = Temp / 16 * 10 + Temp % 16;
 462   1        Temp = DS1302_ReadByte(DS1302_MONTH);
 463   1        DS1302_Time[1] = Temp / 16 * 10 + Temp % 16;
 464   1        Temp = DS1302_ReadByte(DS1302_DATE);
 465   1        DS1302_Time[2] = Temp / 16 * 10 + Temp % 16;
 466   1        Temp = DS1302_ReadByte(DS1302_HOUR);
 467   1        DS1302_Time[3] = Temp / 16 * 10 + Temp % 16;
 468   1        Temp = DS1302_ReadByte(DS1302_MINUTE);
 469   1        DS1302_Time[4] = Temp / 16 * 10 + Temp % 16;
 470   1        Temp = DS1302_ReadByte(DS1302_SECOND);
 471   1        DS1302_Time[5] = Temp / 16 * 10 + Temp % 16;
 472   1        Temp = DS1302_ReadByte(DS1302_DAY);
 473   1        DS1302_Time[6] = Temp / 16 * 10 + Temp % 16;
 474   1      }
 475          
 476          void I2C_Start(void) // I2Cå¼€å§‹
 477          {
C51 COMPILER V9.59.0.0   DALYA                                                             12/01/2024 22:27:34 PAGE 9   

 478   1        I2C_SCL = 1;
 479   1        I2C_SDA = 1;
 480   1        I2C_SDA = 0;
 481   1        I2C_SCL = 0;
 482   1      }
 483          
 484          void I2C_Stop(void) // I2Cåœæ­¢
 485          {
 486   1        I2C_SDA = 0;
 487   1        I2C_SCL = 1;
 488   1        I2C_SDA = 1;
 489   1      }
 490          
 491          void I2C_SendByte(unsigned char Byte) // I2Cå‘é€ä¸€ä¸ªå­—èŠ‚ï¼ŒByteå³è¦å‘é€çš„å­—èŠ‚
 492          {
 493   1        unsigned char i;
 494   1        for (i = 0; i < 8; i++)
 495   1        {
 496   2          I2C_SDA = Byte & (0x80 >> i); // ä¾æ¬¡å–å‡ºByteçš„ä½
 497   2          I2C_SCL = 1;
 498   2          I2C_SCL = 0;
 499   2        }
 500   1      }
 501          
 502          unsigned char I2C_ReceiveByte(void) // I2Cæ¥æ”¶ä¸€ä¸ªå­—èŠ‚å¹¶è¿”å›
 503          {
 504   1        unsigned char Byte = 0x00;
 505   1        unsigned char i = 0;
 506   1      
 507   1        I2C_SDA = 1;
 508   1      
 509   1        for (i = 0; i < 8; i++)
 510   1        {
 511   2          I2C_SCL = 1;
 512   2          if (I2C_SDA)
 513   2          {
 514   3            Byte |= (0x80 >> i);
 515   3          }
 516   2          I2C_SCL = 0;
 517   2        }
 518   1      
 519   1        return Byte;
 520   1      }
 521          
 522          void I2C_SendAck(unsigned char AckBit) // I2Cä¸»æœºå‘é€åº”ç­”ï¼ŒAckBitä¸ºåº”ç­”ï¼Œ0åº”ç­”ï¼Œ1éåº”ç­”
 523          {
 524   1        I2C_SDA = AckBit;
 525   1        I2C_SCL = 1;
 526   1        I2C_SCL = 0;
 527   1      }
 528          
 529          unsigned char I2C_ReceiveAck(void) // I2Cä¸»æœºæ¥æ”¶åº”ç­”
 530          {
 531   1        unsigned char AckBit;
 532   1        I2C_SDA = 1;
 533   1        I2C_SCL = 1;
 534   1        AckBit = I2C_SDA;
 535   1        I2C_SCL = 0;
 536   1        return AckBit;
 537   1      }
 538          
 539          // æ³¨æ„è¾“å…¥çš„WordAddressæ˜¯8ä½åœ°å€ï¼Œæ‰€ä»¥å–å€¼åº”æ˜¯0~255
C51 COMPILER V9.59.0.0   DALYA                                                             12/01/2024 22:27:34 PAGE 10  

 540          void AT24C02_WriterByte(unsigned char WordAddress, unsigned char Data)
 541          {
 542   1        I2C_Start();
 543   1        I2C_SendByte(AT24C02_ADDRESS);
 544   1        I2C_ReceiveAck();
 545   1        I2C_SendByte(WordAddress);
 546   1        I2C_ReceiveAck();
 547   1        I2C_SendByte(Data);
 548   1        I2C_ReceiveAck();
 549   1        I2C_Stop();
 550   1      }
 551          
 552          // æ³¨æ„è¾“å…¥çš„WordAddressæ˜¯8ä½åœ°å€ï¼Œæ‰€ä»¥å–å€¼åº”æ˜¯0~255
 553          unsigned char AT24C02_ReadByte(unsigned char WordAddress)
 554          {
 555   1        unsigned char Data = 0;
 556   1        I2C_Start();
 557   1        I2C_SendByte(AT24C02_ADDRESS);
 558   1        I2C_ReceiveAck();
 559   1        I2C_SendByte(WordAddress);
 560   1        I2C_ReceiveAck();
 561   1        I2C_Start();
 562   1        I2C_SendByte(AT24C02_ADDRESS | 0x01);
 563   1        I2C_ReceiveAck();
 564   1        Data = I2C_ReceiveByte();
 565   1        I2C_SendAck(1);
 566   1        I2C_Stop();
 567   1      
 568   1        return Data;
 569   1      }
 570          
 571          void LCD_Delay()
 572          {
 573   1        unsigned char i, j;
 574   1      
 575   1        i = 2;
 576   1        j = 239;
 577   1        do
 578   1        {
 579   2          while (--j)
 580   2            ;
 581   2        } while (--i);
 582   1      }
 583          
 584          void LCD_WriteCommand(unsigned char Command)
 585          {
 586   1        LCD_RS = 0;
 587   1        LCD_RW = 0;
 588   1        LCD_DataPort = Command;
 589   1        LCD_EN = 1;
 590   1        LCD_Delay();
 591   1        LCD_EN = 0;
 592   1        LCD_Delay();
 593   1      }
 594          
 595          void LCD_WriteData(unsigned char Data)
 596          {
 597   1        LCD_RS = 1;
 598   1        LCD_RW = 0;
 599   1        LCD_DataPort = Data;
 600   1        LCD_EN = 1;
 601   1        LCD_Delay();
C51 COMPILER V9.59.0.0   DALYA                                                             12/01/2024 22:27:34 PAGE 11  

 602   1        LCD_EN = 0;
 603   1        LCD_Delay();
 604   1      }
 605          
 606          void LCD_Init()
 607          {
 608   1        LCD_WriteCommand(0x38);
 609   1        LCD_WriteCommand(0x0c);
 610   1        LCD_WriteCommand(0x06);
 611   1        LCD_WriteCommand(0x01);
 612   1      }
 613          
 614          void LCD_SetCursor(unsigned char Line, unsigned char Column)
 615          {
 616   1        if (Line == 1)
 617   1        {
 618   2          LCD_WriteCommand(0x80 | (Column - 1));
 619   2        }
 620   1        else if (Line == 2)
 621   1        {
 622   2          LCD_WriteCommand(0x80 | (Column - 1 + 0x40));
 623   2        }
 624   1      }
 625          
 626          void LCD_ShowChar(unsigned char Line, unsigned char Column, unsigned char Char)
 627          {
 628   1        LCD_SetCursor(Line, Column);
 629   1        LCD_WriteData(Char);
 630   1      }
 631          
 632          void LCD_ShowString(unsigned char Line, unsigned char Column, unsigned char String[])
 633          {
 634   1        unsigned char i = 0;
 635   1      
 636   1        LCD_SetCursor(Line, Column);
 637   1      
 638   1        for (i = 0; String[i] != '\0'; i++)
 639   1        {
 640   2          LCD_WriteData(String[i]);
 641   2        }
 642   1      }
 643          
 644          int LCD_Pow(int X, int Y)
 645          {
 646   1        unsigned char i = 0;
 647   1        int Result = 1;
 648   1        for (i = 0; i < Y; i++)
 649   1        {
 650   2          Result *= X;
 651   2        }
 652   1        return Result;
 653   1      }
 654          
 655          void LCD_ShowNum(unsigned char Line, unsigned char Column, unsigned int Number, unsigned char Length)
 656          {
 657   1        unsigned char i = 0;
 658   1        LCD_SetCursor(Line, Column);
 659   1      
 660   1        for (i = Length; i > 0; i--)
 661   1        {
 662   2          LCD_WriteData(Number / LCD_Pow(10, i - 1) % 10 + '0');
 663   2        }
C51 COMPILER V9.59.0.0   DALYA                                                             12/01/2024 22:27:34 PAGE 12  

 664   1      }
 665          
 666          void LCD_ShowSignedNum(unsigned char Line, unsigned char Column, int Number, unsigned char Length)
 667          {
 668   1        unsigned char i = 0;
 669   1        unsigned int Number1 = 0;
 670   1        LCD_SetCursor(Line, Column);
 671   1        if (Number >= 0)
 672   1        {
 673   2          LCD_WriteData('+');
 674   2          Number1 = Number;
 675   2        }
 676   1        else
 677   1        {
 678   2          LCD_WriteData('-');
 679   2          Number1 = -Number;
 680   2        }
 681   1        for (i = Length; i > 0; i--)
 682   1        {
 683   2          LCD_WriteData(Number1 / LCD_Pow(10, i - 1) % 10 + '0');
 684   2        }
 685   1      }
 686          
 687          void LCD_ShowHexNum(unsigned char Line, unsigned char Column, unsigned int Number, unsigned char Length)
 688          {
 689   1        unsigned char i = 0;
 690   1        unsigned char SingleNumber = 0;
 691   1        LCD_SetCursor(Line, Column);
 692   1      
 693   1        for (i = Length; i > 0; i--)
 694   1        {
 695   2          SingleNumber = Number / LCD_Pow(16, i - 1) % 16;
 696   2          if (SingleNumber < 10)
 697   2          {
 698   3            LCD_WriteData(SingleNumber + '0');
 699   3          }
 700   2          else
 701   2          {
 702   3            LCD_WriteData(SingleNumber - 10 + 'A');
 703   3          }
 704   2        }
 705   1      }
 706          
 707          void LCD_ShowBinNum(unsigned char Line, unsigned char Column, unsigned int Number, unsigned char Length)
 708          {
 709   1        unsigned char i = 0;
 710   1        LCD_SetCursor(Line, Column);
 711   1      
 712   1        for (i = Length; i > 0; i--)
 713   1        {
 714   2          LCD_WriteData(Number / LCD_Pow(2, i - 1) % 2 + '0');
 715   2        }
 716   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1854    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      7      42
   IDATA SIZE       =   ----    ----
C51 COMPILER V9.59.0.0   DALYA                                                             12/01/2024 22:27:34 PAGE 13  

   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
