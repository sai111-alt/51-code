C51 COMPILER V9.59.0.0   DALYA                                                             12/01/2024 17:51:25 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE DALYA
OBJECT MODULE PLACED IN .\Objects\Dalya.obj
COMPILER INVOKED BY: D:\RJ\Keil5\C51\BIN\C51.EXE Dalya.c OPTIMIZE(8,SPEED) BROWSE INCDIR(D:\RJ\Keil5\C51\INC;D:\RJ\Keil5
                    -\C51\INC\Atmel) DEBUG OBJECTEXTEND PRINT(.\Listings\Dalya.lst) TABS(2) OBJECT(.\Objects\Dalya.obj)

line level    source

   1          #include "Delay.h"
   2          
   3          // å‡½æ•°å®šä¹‰ï¼š
   4          /**
   5           * @brief  LCD1602å»¶æ—¶å‡½æ•°ï¼Œ12MHzè°ƒç”¨å¯å»¶æ—¶1ms
   6           * @param  æ— 
   7           * @retval æ— 
   8           */
   9          void LCD_Delay()
  10          {
  11   1        unsigned char i, j;
  12   1      
  13   1        i = 2;
  14   1        j = 239;
  15   1        do
  16   1        {
  17   2          while (--j)
  18   2            ;
  19   2        } while (--i);
  20   1      }
  21          
  22          /**
  23           * @brief  LCD1602å†™å‘½ä»¤
  24           * @param  Command è¦å†™å…¥çš„å‘½ä»¤
  25           * @retval æ— 
  26           */
  27          void LCD_WriteCommand(unsigned char Command)
  28          {
  29   1        LCD_RS = 0;
  30   1        LCD_RW = 0;
  31   1        LCD_DataPort = Command;
  32   1        LCD_EN = 1;
  33   1        LCD_Delay();
  34   1        LCD_EN = 0;
  35   1        LCD_Delay();
  36   1      }
  37          
  38          /**
  39           * @brief  LCD1602å†™æ•°æ®
  40           * @param  Data è¦å†™å…¥çš„æ•°æ®
  41           * @retval æ— 
  42           */
  43          void LCD_WriteData(unsigned char Data)
  44          {
  45   1        LCD_RS = 1;
  46   1        LCD_RW = 0;
  47   1        LCD_DataPort = Data;
  48   1        LCD_EN = 1;
  49   1        LCD_Delay();
  50   1        LCD_EN = 0;
  51   1        LCD_Delay();
  52   1      }
  53          
  54          /**
C51 COMPILER V9.59.0.0   DALYA                                                             12/01/2024 17:51:25 PAGE 2   

  55           * @brief  LCD1602è®¾ç½®å…‰æ ‡ä½ç½®
  56           * @param  Line è¡Œä½ç½®ï¼ŒèŒƒå›´ï¼š1~2
  57           * @param  Column åˆ—ä½ç½®ï¼ŒèŒƒå›´ï¼š1~16
  58           * @retval æ— 
  59           */
  60          void LCD_SetCursor(unsigned char Line, unsigned char Column)
  61          {
  62   1        if (Line == 1)
  63   1        {
  64   2          LCD_WriteCommand(0x80 | (Column - 1));
  65   2        }
  66   1        else if (Line == 2)
  67   1        {
  68   2          LCD_WriteCommand(0x80 | (Column - 1 + 0x40));
  69   2        }
  70   1      }
  71          
  72          /**
  73           * @brief  LCD1602åˆå§‹åŒ–å‡½æ•°
  74           * @param  æ— 
  75           * @retval æ— 
  76           */
  77          void LCD_Init()
  78          {
  79   1        LCD_WriteCommand(0x38); // å…«ä½æ•°æ®æ¥å£ï¼Œä¸¤è¡Œæ˜¾ç¤ºï¼Œ5*7ç‚¹é˜µ
  80   1        LCD_WriteCommand(0x0c); // æ˜¾ç¤ºå¼€ï¼Œå…‰æ ‡å…³ï¼Œé—ªçƒå…³
  81   1        LCD_WriteCommand(0x06); // æ•°æ®è¯»å†™æ“ä½œåï¼Œå…‰æ ‡è‡ªåŠ¨åŠ ä¸€ï¼Œç”»é¢ä¸åŠ¨
  82   1        LCD_WriteCommand(0x01); // å…‰æ ‡å¤ä½ï¼Œæ¸…å±
  83   1      }
  84          
  85          /**
  86           * @brief  åœ¨LCD1602æŒ‡å®šä½ç½®ä¸Šæ˜¾ç¤ºä¸€ä¸ªå­—ç¬¦
  87           * @param  Line è¡Œä½ç½®ï¼ŒèŒƒå›´ï¼š1~2
  88           * @param  Column åˆ—ä½ç½®ï¼ŒèŒƒå›´ï¼š1~16
  89           * @param  Char è¦æ˜¾ç¤ºçš„å­—ç¬¦
  90           * @retval æ— 
  91           */
  92          void LCD_ShowChar(unsigned char Line, unsigned char Column, char Char)
  93          {
  94   1        LCD_SetCursor(Line, Column);
  95   1        LCD_WriteData(Char);
  96   1      }
  97          
  98          /**
  99           * @brief  åœ¨LCD1602æŒ‡å®šä½ç½®å¼€å§‹æ˜¾ç¤ºæ‰€ç»™å­—ç¬¦ä¸²
 100           * @param  Line èµ·å§‹è¡Œä½ç½®ï¼ŒèŒƒå›´ï¼š1~2
 101           * @param  Column èµ·å§‹åˆ—ä½ç½®ï¼ŒèŒƒå›´ï¼š1~16
 102           * @param  String è¦æ˜¾ç¤ºçš„å­—ç¬¦ä¸²
 103           * @retval æ— 
 104           */
 105          void LCD_ShowString(unsigned char Line, unsigned char Column, char *String)
 106          {
 107   1        unsigned char i;
 108   1        LCD_SetCursor(Line, Column);
 109   1        for (i = 0; String[i] != '\0'; i++)
 110   1        {
 111   2          LCD_WriteData(String[i]);
 112   2        }
 113   1      }
 114          
 115          /**
 116           * @brief  è¿”å›å€¼=Xçš„Yæ¬¡æ–¹
C51 COMPILER V9.59.0.0   DALYA                                                             12/01/2024 17:51:25 PAGE 3   

 117           */
 118          int LCD_Pow(int X, int Y)
 119          {
 120   1        unsigned char i;
 121   1        int Result = 1;
 122   1        for (i = 0; i < Y; i++)
 123   1        {
 124   2          Result *= X;
 125   2        }
 126   1        return Result;
 127   1      }
 128          
 129          /**
 130           * @brief  åœ¨LCD1602æŒ‡å®šä½ç½®å¼€å§‹æ˜¾ç¤ºæ‰€ç»™æ•°å­—
 131           * @param  Line èµ·å§‹è¡Œä½ç½®ï¼ŒèŒƒå›´ï¼š1~2
 132           * @param  Column èµ·å§‹åˆ—ä½ç½®ï¼ŒèŒƒå›´ï¼š1~16
 133           * @param  Number è¦æ˜¾ç¤ºçš„æ•°å­—ï¼ŒèŒƒå›´ï¼š0~65535
 134           * @param  Length è¦æ˜¾ç¤ºæ•°å­—çš„é•¿åº¦ï¼ŒèŒƒå›´ï¼š1~5
 135           * @retval æ— 
 136           */
 137          void LCD_ShowNum(unsigned char Line, unsigned char Column, unsigned int Number, unsigned char Length)
 138          {
 139   1        unsigned char i;
 140   1        LCD_SetCursor(Line, Column);
 141   1        for (i = Length; i > 0; i--)
 142   1        {
 143   2          LCD_WriteData(Number / LCD_Pow(10, i - 1) % 10 + '0');
 144   2        }
 145   1      }
 146          
 147          /**
 148           * @brief  åœ¨LCD1602æŒ‡å®šä½ç½®å¼€å§‹ä»¥æœ‰ç¬¦å·åè¿›åˆ¶æ˜¾ç¤ºæ‰€ç»™æ•°å­—
 149           * @param  Line èµ·å§‹è¡Œä½ç½®ï¼ŒèŒƒå›´ï¼š1~2
 150           * @param  Column èµ·å§‹åˆ—ä½ç½®ï¼ŒèŒƒå›´ï¼š1~16
 151           * @param  Number è¦æ˜¾ç¤ºçš„æ•°å­—ï¼ŒèŒƒå›´ï¼š-32768~32767
 152           * @param  Length è¦æ˜¾ç¤ºæ•°å­—çš„é•¿åº¦ï¼ŒèŒƒå›´ï¼š1~5
 153           * @retval æ— 
 154           */
 155          void LCD_ShowSignedNum(unsigned char Line, unsigned char Column, int Number, unsigned char Length)
 156          {
 157   1        unsigned char i;
 158   1        unsigned int Number1;
 159   1        LCD_SetCursor(Line, Column);
 160   1        if (Number >= 0)
 161   1        {
 162   2          LCD_WriteData('+');
 163   2          Number1 = Number;
 164   2        }
 165   1        else
 166   1        {
 167   2          LCD_WriteData('-');
 168   2          Number1 = -Number;
 169   2        }
 170   1        for (i = Length; i > 0; i--)
 171   1        {
 172   2          LCD_WriteData(Number1 / LCD_Pow(10, i - 1) % 10 + '0');
 173   2        }
 174   1      }
 175          
 176          /**
 177           * @brief  åœ¨LCD1602æŒ‡å®šä½ç½®å¼€å§‹ä»¥åå…­è¿›åˆ¶æ˜¾ç¤ºæ‰€ç»™æ•°å­—
 178           * @param  Line èµ·å§‹è¡Œä½ç½®ï¼ŒèŒƒå›´ï¼š1~2
C51 COMPILER V9.59.0.0   DALYA                                                             12/01/2024 17:51:25 PAGE 4   

 179           * @param  Column èµ·å§‹åˆ—ä½ç½®ï¼ŒèŒƒå›´ï¼š1~16
 180           * @param  Number è¦æ˜¾ç¤ºçš„æ•°å­—ï¼ŒèŒƒå›´ï¼š0~0xFFFF
 181           * @param  Length è¦æ˜¾ç¤ºæ•°å­—çš„é•¿åº¦ï¼ŒèŒƒå›´ï¼š1~4
 182           * @retval æ— 
 183           */
 184          void LCD_ShowHexNum(unsigned char Line, unsigned char Column, unsigned int Number, unsigned char Length)
 185          {
 186   1        unsigned char i, SingleNumber;
 187   1        LCD_SetCursor(Line, Column);
 188   1        for (i = Length; i > 0; i--)
 189   1        {
 190   2          SingleNumber = Number / LCD_Pow(16, i - 1) % 16;
 191   2          if (SingleNumber < 10)
 192   2          {
 193   3            LCD_WriteData(SingleNumber + '0');
 194   3          }
 195   2          else
 196   2          {
 197   3            LCD_WriteData(SingleNumber - 10 + 'A');
 198   3          }
 199   2        }
 200   1      }
 201          
 202          /**
 203           * @brief  åœ¨LCD1602æŒ‡å®šä½ç½®å¼€å§‹ä»¥äºŒè¿›åˆ¶æ˜¾ç¤ºæ‰€ç»™æ•°å­—
 204           * @param  Line èµ·å§‹è¡Œä½ç½®ï¼ŒèŒƒå›´ï¼š1~2
 205           * @param  Column èµ·å§‹åˆ—ä½ç½®ï¼ŒèŒƒå›´ï¼š1~16
 206           * @param  Number è¦æ˜¾ç¤ºçš„æ•°å­—ï¼ŒèŒƒå›´ï¼š0~1111 1111 1111 1111
 207           * @param  Length è¦æ˜¾ç¤ºæ•°å­—çš„é•¿åº¦ï¼ŒèŒƒå›´ï¼š1~16
 208           * @retval æ— 
 209           */
 210          void LCD_ShowBinNum(unsigned char Line, unsigned char Column, unsigned int Number, unsigned char Length)
 211          {
 212   1        unsigned char i;
 213   1        LCD_SetCursor(Line, Column);
 214   1        for (i = Length; i > 0; i--)
 215   1        {
 216   2          LCD_WriteData(Number / LCD_Pow(2, i - 1) % 2 + '0');
 217   2        }
 218   1      }
 219          
 220          void Delay(unsigned int xms) //@12MHz
 221          {
 222   1        unsigned char data i, j;
 223   1      
 224   1        while (xms--)
 225   1        {
 226   2          i = 2;
 227   2          j = 239;
 228   2          do
 229   2          {
 230   3            while (--j)
 231   3              ;
 232   3          } while (--i);
 233   2        }
 234   1      }
 235          
 236          unsigned char Nixie_Buf[9] = {0, 10, 10, 10, 10, 10, 10, 10, 10};
 237          
 238          unsigned char NixieTable[] = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F, 0X00, 0x40};
 239          
 240          void Nixie_SetBuf(unsigned char Location, unsigned char Number)
C51 COMPILER V9.59.0.0   DALYA                                                             12/01/2024 17:51:25 PAGE 5   

 241          {
 242   1        Nixie_Buf[Location] = Number;
 243   1      }
 244          
 245          void NixieTube_Scan(unsigned char Location, unsigned char Number)
 246          {
 247   1        // è¦åŒæ—¶æ˜¾ç¤ºå¤šä¸ªæ•°ç ç®¡ï¼Œéœ€è¦æ¶ˆå½±
 248   1        // æ˜¾ç¤ºå¤šä¸ªæ•°ç ç®¡ï¼šæ˜¯å…ˆè¿›è¡Œè¿™ä¸ªæ•°ç çš„ä½é€‰ï¼Œå†å¯¹å…¶æ®µé€‰
 249   1        // ç„¶åå†å¯¹ä¸‹ä¸€ä¸ªæ•°ç ç®¡è¿›è¡Œä½é€‰ï¼Œå†æ®µé€‰ï¼Œä¾æ¬¡ç±»æ¨
 250   1        // é€»è¾‘å°±æ˜¯ï¼šä½é€‰ æ®µé€‰ â†’ ä¸‹ä¸€ä¸ªæ•°ç ç®¡ä½é€‰ æ®µé€‰
 251   1        // è¿™æ®µé€‰åˆ°ä¸‹ä¸€ä¸ªä½é€‰ä¹‹é—´ï¼Œå› ä¸ºé€Ÿåº¦å¾ˆå¿«ï¼Œä¼šå¯¼è‡´ä¸Šä¸ªæ®µé€‰
 252   1        // çš„æ•°æ®ä¼šä¸²åˆ°ä¸‹ä¸€ä¸ªä½é€‰ä¸Šï¼Œä»è€Œäº§ç”Ÿå½±å­
 253   1        // æ‰€ä»¥æˆ‘ä»¬åœ¨è¿™ä¸ªé€»è¾‘ä¹‹é—´åŠ ä¸Šä¸€ä¸ªæ¸…é›¶å°±å¥½äº†ï¼Œè®©æ•°ç é¦†ä¸æ˜¾ç¤º
 254   1        // å³ï¼šä½é€‰ æ®µé€‰ æ¸…é›¶ ä¸‹ä¸€ä¸ªæ•°ç ç®¡ä½é€‰ æ®µé€‰
 255   1        // ä»¥ä¸‹ç¨‹åºç”¨äºæ•°ç ç®¡æ¶ˆå½±ï¼š
 256   1        // Delay(1);  // å…ˆå»¶æ—¶1msï¼Œå¦‚æœç«‹é©¬æ¸…é›¶ï¼Œåªæ˜¯ä¼šè®©åŸæ¥çš„æ•°ç ç®¡å˜æš—
 257   1        // è¿™é‡Œç”¨å®šæ—¶å™¨æ¥å–ä»£Delayçš„åŠŸèƒ½
 258   1        P0 = 0x00; // æ¸…é›¶
 259   1        switch (Location)
 260   1        {
 261   2        case 1:
 262   2          P2_4 = 1;
 263   2          P2_3 = 1;
 264   2          P2_2 = 1;
 265   2          break;
 266   2        case 2:
 267   2          P2_4 = 1;
 268   2          P2_3 = 1;
 269   2          P2_2 = 0;
 270   2          break;
 271   2        case 3:
 272   2          P2_4 = 1;
 273   2          P2_3 = 0;
 274   2          P2_2 = 1;
 275   2          break;
 276   2        case 4:
 277   2          P2_4 = 1;
 278   2          P2_3 = 0;
 279   2          P2_2 = 0;
 280   2          break;
 281   2        case 5:
 282   2          P2_4 = 0;
 283   2          P2_3 = 1;
 284   2          P2_2 = 1;
 285   2          break;
 286   2        case 6:
 287   2          P2_4 = 0;
 288   2          P2_3 = 1;
 289   2          P2_2 = 0;
 290   2          break;
 291   2        case 7:
 292   2          P2_4 = 0;
 293   2          P2_3 = 0;
 294   2          P2_2 = 1;
 295   2          break;
 296   2        case 8:
 297   2          P2_4 = 0;
 298   2          P2_3 = 0;
 299   2          P2_2 = 0;
 300   2          break;
 301   2        }
 302   1        P0 = NixieTable[Number];
C51 COMPILER V9.59.0.0   DALYA                                                             12/01/2024 17:51:25 PAGE 6   

 303   1      }
 304          
 305          void NixieTube_Loop(void) // æ­¤å‡½æ•°ä¸timeré…åˆï¼Œæ¯2msæ‰§è¡Œä¸€æ¬¡æ­¤å‡½æ•°ï¼Œå³åŠ¨æ€åˆ·æ–°æ•°ç 
             -ç®¡çš„1åˆ°8ä½
 306          {
 307   1        static unsigned char i = 1;
 308   1        NixieTube_Scan(i, Nixie_Buf[i]); // è¿™é‡Œä½é€‰ä¸ä½é€‰å¯¹åº”
 309   1        i++;
 310   1        if (i >= 9)
 311   1        {
 312   2          i = 1;
 313   2        }
 314   1      }
 315          
 316          // ä½œç”¨æ˜¯è·å–çŸ©é˜µé”®ç›˜ï¼ŒèŒƒå›´ä¸º0~16ï¼Œæ— æŒ‰é”®æŒ‰ä¸‹è¿”å›å€¼ä¸º0
 317          unsigned char MatrixKeyboard()
 318          {
 319   1        unsigned char KeyNumber = 0;
 320   1      
 321   1        P1 = 0xFF;
 322   1        P1_3 = 0; /*ç»“åˆç”µè·¯åŸç†å›¾ï¼Œå½“P1_3=0ï¼Œå…¶ä»–åˆ—ä¸º1æ—¶ï¼Œåˆ™æ£€æµ‹ç¬¬1åˆ—ï¼Œå½“æœ‰æŒ‰é”®æŒ‰ä¸‹æ
             -—¶ï¼Œ
 323   1                 æ¯”å¦‚S1è¢«æŒ‰ä¸‹ï¼Œé‚£ä¹ˆç”µè·¯å¯¼é€šï¼Œä¼šä½¿å¾—P1_7=0;åä¹‹ï¼Œè‹¥P1_7=0,åˆ™S1è¢«æŒ‰ä¸‹ï¼Œ
 324   1                 æ‰€ä»¥æˆ‘ä»¬ä¾æ¬¡åˆ¤æ–­å¯¹åº”4ä¸ªIOå£æ˜¯å¦ä¸º0å°±å¯ä»¥çŸ¥é“å“ªä¸ªæŒ‰é”®è¢«æŒ‰ä¸‹äº†ï¼Œ
 325   1                 ç„¶åä¾æ¬¡åˆ‡æ¢å¯¹åº”åˆ—ï¼Œé€ä¸ªæ‰«æå°±èƒ½è¯†åˆ«æ•´ä¸ªçŸ©é˜µé”®ç›˜å“ªä¸ªæŒ‰é”®è¢«æŒ‰ä¸‹äº†ã€‚
             -*/
 326   1        if (P1_7 == 0)
 327   1        {
 328   2          Delay(100);
 329   2          while (P1_7 == 0)
 330   2            ;
 331   2          Delay(100);
 332   2          KeyNumber = 1;
 333   2        }
 334   1        if (P1_6 == 0)
 335   1        {
 336   2          Delay(100);
 337   2          while (P1_7 == 0)
 338   2            ;
 339   2          Delay(100);
 340   2          KeyNumber = 5;
 341   2        }
 342   1        if (P1_5 == 0)
 343   1        {
 344   2          Delay(100);
 345   2          while (P1_7 == 0)
 346   2            ;
 347   2          Delay(100);
 348   2          KeyNumber = 9;
 349   2        }
 350   1        if (P1_4 == 0)
 351   1        {
 352   2          Delay(100);
 353   2          while (P1_7 == 0)
 354   2            ;
 355   2          Delay(100);
 356   2          KeyNumber = 13;
 357   2        }
 358   1      
 359   1        P1 = 0xFF;
 360   1        P1_2 = 0;
 361   1        if (P1_7 == 0)
C51 COMPILER V9.59.0.0   DALYA                                                             12/01/2024 17:51:25 PAGE 7   

 362   1        {
 363   2          Delay(100);
 364   2          while (P1_7 == 0)
 365   2            ;
 366   2          Delay(100);
 367   2          KeyNumber = 2;
 368   2        }
 369   1        if (P1_6 == 0)
 370   1        {
 371   2          Delay(100);
 372   2          while (P1_7 == 0)
 373   2            ;
 374   2          Delay(100);
 375   2          KeyNumber = 6;
 376   2        }
 377   1        if (P1_5 == 0)
 378   1        {
 379   2          Delay(100);
 380   2          while (P1_7 == 0)
 381   2            ;
 382   2          Delay(100);
 383   2          KeyNumber = 10;
 384   2        }
 385   1        if (P1_4 == 0)
 386   1        {
 387   2          Delay(100);
 388   2          while (P1_7 == 0)
 389   2            ;
 390   2          Delay(100);
 391   2          KeyNumber = 14;
 392   2        }
 393   1      
 394   1        P1 = 0xFF;
 395   1        P1_1 = 0;
 396   1        if (P1_7 == 0)
 397   1        {
 398   2          Delay(100);
 399   2          while (P1_7 == 0)
 400   2            ;
 401   2          Delay(100);
 402   2          KeyNumber = 3;
 403   2        }
 404   1        if (P1_6 == 0)
 405   1        {
 406   2          Delay(100);
 407   2          while (P1_7 == 0)
 408   2            ;
 409   2          Delay(100);
 410   2          KeyNumber = 7;
 411   2        }
 412   1        if (P1_5 == 0)
 413   1        {
 414   2          Delay(100);
 415   2          while (P1_7 == 0)
 416   2            ;
 417   2          Delay(100);
 418   2          KeyNumber = 11;
 419   2        }
 420   1        if (P1_4 == 0)
 421   1        {
 422   2          Delay(100);
 423   2          while (P1_7 == 0)
C51 COMPILER V9.59.0.0   DALYA                                                             12/01/2024 17:51:25 PAGE 8   

 424   2            ;
 425   2          Delay(100);
 426   2          KeyNumber = 15;
 427   2        }
 428   1      
 429   1        P1 = 0xFF;
 430   1        P1_0 = 0;
 431   1        if (P1_7 == 0)
 432   1        {
 433   2          Delay(100);
 434   2          while (P1_7 == 0)
 435   2            ;
 436   2          Delay(100);
 437   2          KeyNumber = 4;
 438   2        }
 439   1        if (P1_6 == 0)
 440   1        {
 441   2          Delay(100);
 442   2          while (P1_7 == 0)
 443   2            ;
 444   2          Delay(100);
 445   2          KeyNumber = 8;
 446   2        }
 447   1        if (P1_5 == 0)
 448   1        {
 449   2          Delay(100);
 450   2          while (P1_7 == 0)
 451   2            ;
 452   2          Delay(100);
 453   2          KeyNumber = 12;
 454   2        }
 455   1        if (P1_4 == 0)
 456   1        {
 457   2          Delay(100);
 458   2          while (P1_7 == 0)
 459   2            ;
 460   2          Delay(100);
 461   2          KeyNumber = 16;
 462   2        }
 463   1      
 464   1        return KeyNumber;
 465   1      }
 466          
 467          void Timer0_Init() // 1ms@12MHz
 468          {
 469   1        TMOD &= 0xF0; // æŠŠTMODçš„ä½å››ä½æ¸…é›¶ï¼Œé«˜å››ä½ä¿æŒä¸å˜
 470   1        TMOD |= 0x01; // æŠŠTMODçš„æœ€ä½ä½ç½®1ï¼Œå…¶ä»–7ä½ä¿æŒä¸å˜ï¼Œè¿™é‡Œå³è®¾ç½®äº†å®šæ—¶å™¨0çš„æ¨¡å¼
             -æ˜¯å·¥ä½œæ–¹å¼1ï¼š16ä¸ºè®¡æ•°å™¨
 471   1        // è¿™æ ·åšçš„å¥½å¤„å°±åœ¨äºå¯ä»¥åªæ“ä½œTMODçš„å…¶ä¸­æŸäº›ä½è€Œä¸å½±å“å…¶ä»–ä½
 472   1      
 473   1        TF0 = 0; // è®¾ç½®T0å®šæ—¶å™¨æº¢å‡ºæ ‡å¿—ä½ä¸º0
 474   1        TR0 = 1; // å³å¯åŠ¨å®šæ—¶å™¨0å¼€å§‹è®¡æ—¶
 475   1      
 476   1        TH0 = 0xFC; // è®¾ç½®å®šæ—¶åˆå§‹å€¼ä¸º64535+1
 477   1        TL0 = 0x18;
 478   1        // å¦ä¸€å†™æ³•
 479   1        //  TH0=64535/256;//ä½œç”¨å³å¾—åˆ°64535è½¬16è¿›åˆ¶åçš„é«˜8ä½ï¼Œè¿™é‡Œé™¤çš„ç»“æœåªå–æ•´æ•°ï¼Œä¸å–
             -å°æ•°
 480   1        //                ï¼ˆç»“æœå³åè¿›åˆ¶çš„252ï¼Œè½¬16è¿›åˆ¶å°±æ˜¯FCï¼Œåˆšå¥½å°±æ˜¯64535çš„åå…­è¿›åˆ¶é«˜8ä½ï¼‰
 481   1        //  TL0=64535%256+1;//ç»“æœå³64535è½¬16è¿›åˆ¶åçš„ä½8ä½ï¼ˆåŒç†ï¼Œè‡ªå·±è®¡ç®—ï¼‰ï¼Œ+1æ˜¯å› ä¸ºå®šæ—
             -¶å™¨
 482   1        // æœ€å¤§å®šæ—¶ä¸º65535ï¼Œè€Œå®šæ—¶å™¨è¦åˆ°65536æ‰æº¢å‡ºï¼Œæ‰€ä»¥64535åˆ°65536æ˜¯1001ï¼Œå¤šäº†1å¾®ç§’ï¼
C51 COMPILER V9.59.0.0   DALYA                                                             12/01/2024 17:51:25 PAGE 9   

             -Œè¿™æ ·å®šæ—¶å°±æ˜¯1.001ms
 483   1      
 484   1        ET0 = 1; // T0å¯¹åº”çš„ä¸­æ–­å¼€å…³é—­åˆ
 485   1        EA = 1;  // ä¸­æ–­æ€»å¼€å…³é—­åˆ
 486   1        PT0 = 0; // è®¾ç½®ä¸­æ–­ä¼˜å…ˆçº§ä¸ºä½çº§
 487   1      }
 488          
 489          /*ä¸Šé¢çš„çš„å®šæ—¶å™¨åˆå§‹åŒ–ç¨‹åºè¦é…åˆä¸‹é¢çš„å®šæ—¶å™¨ä¸­æ–­ç¨‹åºæ¨¡æ¿ï¼Œåªä¸è¿‡ä¸­æ–­ç¨‹åº
             -è¦å†™åˆ°ä¸»å‡½æ•°æ–‡ä»¶ä¸ä¸»å‡½æ•°é…åˆ
 490          void Timer0_Routine() interrupt 1 //å®šæ—¶å™¨T0çš„ä¸­æ–­ç¨‹åºå‡½æ•°å‘½åéšæ„ï¼Œinterrupt 1ç”¨äºå°†æ­¤
             -å‡½æ•°å®šä¹‰ä¸ºå®šæ—¶å™¨0çš„ä¸­æ–­ç¨‹åº
 491          {
 492            static unsigned int T0Count;//é™æ€å˜é‡ä½¿å¾—è¯¥å˜é‡å‡ºäº†æ­¤å‡½æ•°ä»ç„¶ä¸ä¼šè¢«é”€æ¯
 493            TH0=0xFC;//æ¯æ¬¡è®¡æ—¶è®¡å®Œåéœ€è¦é‡æ–°èµ‹åˆå€¼ï¼Œè‹¥
 494            TL0=0x18;//ä¸èµ‹åˆå€¼ï¼Œå®ƒä¼šé»˜è®¤é‡0å¼€å§‹è®¡æ—¶,è¿™é‡Œè®¾ç½®çš„æ—¶æ¯éš”1msæ‰§è¡Œä¸€æ¬¡ä¸­æ–­
 495            T0Count++;
 496            if(T0Count>=1000)
 497            {
 498              T0Count=0;
 499          
 500            }
 501          }
 502          */
 503          
 504          // ç‹¬ç«‹é”®ç›˜é”®ç 
 505          unsigned char Key_KeyNumber = 0;
 506          
 507          // è·å–å½“ä¸‹å·²ç»è¢«æŒ‰ä¸‹æŠ¬èµ·çš„ç‹¬ç«‹æŒ‰é”®ç 
 508          unsigned char Key(void)
 509          {
 510   1        unsigned char Temp = 0;
 511   1        Temp = Key_KeyNumber;
 512   1        Key_KeyNumber = 0;
 513   1        return Temp;
 514   1      }
 515          
 516          // ä½œç”¨æ˜¯è·å–ç‹¬ç«‹æŒ‰é”®æ˜¯å¦è¢«æŒ‰ä¸‹ï¼ŒèŒƒå›´ä¸º0~4ï¼Œæ— æŒ‰é”®æŒ‰ä¸‹è¿”å›å€¼ä¸º0
 517          unsigned char IndependentKey_Getstate()
 518          {
 519   1        unsigned char KeyNumber = 0;
 520   1      
 521   1        if (P3_1 == 0)
 522   1        {
 523   2          KeyNumber = 1;
 524   2        }
 525   1        if (P3_0 == 0)
 526   1        {
 527   2          Delay(100);
 528   2          KeyNumber = 2;
 529   2        }
 530   1        if (P3_2 == 0)
 531   1        {
 532   2          KeyNumber = 3;
 533   2        }
 534   1        if (P3_3 == 0)
 535   1        {
 536   2          KeyNumber = 4;
 537   2        }
 538   1      
 539   1        return KeyNumber;
 540   1      }
 541          
C51 COMPILER V9.59.0.0   DALYA                                                             12/01/2024 17:51:25 PAGE 10  

 542          void IndependentKey_Loop(void)
 543          {
 544   1        static unsigned char NowState = 0;
 545   1        static unsigned char LastState = 0;
 546   1        LastState = NowState;
 547   1        NowState = IndependentKey_Getstate();
 548   1        if (LastState == 1 && NowState == 0) // å½“LastState = 1æ—¶ï¼Œè¡¨ç¤ºä¸Šä¸ªçŠ¶æ€æŒ‰é”®1è¢«æŒ‰ä¸‹
 549   1        {                  // åŒæ—¶è‹¥NowState = 0æ—¶ï¼Œåˆ™è¡¨ç¤ºç°åœ¨æ²¡æœ‰æŒ‰é”®æŒ‰ä¸‹
 550   2          Key_KeyNumber = 1;         // LastState == 1 && NowState == 0åˆ™è¡¨ç¤ºæŒ‰é”®è¢«æŒ‰ä¸‹äº†ä¸”æŒ‰é”®ç°åœ¨å¼¹èµ
             -·äº†
 551   2        }
 552   1        if (LastState == 2 && NowState == 0)
 553   1        {
 554   2          Key_KeyNumber = 2;
 555   2        }
 556   1        if (LastState == 3 && NowState == 0)
 557   1        {
 558   2          Key_KeyNumber = 3;
 559   2        }
 560   1        if (LastState == 4 && NowState == 0)
 561   1        {
 562   2          Key_KeyNumber = 4;
 563   2        }
 564   1      }
 565          
 566          void UART_Init() // æ³¢ç‰¹ç‡4800
 567          {
 568   1        SCON = 0x50;  // å…¶ä»–åˆå§‹åŒ–ä¸º0ï¼Œè€Œé€‰æ‹©å·¥ä½œæ–¹å¼ä¸º1ä¸”RENç½®ä¸º1å…è®¸ä¸²å£æ¥å—æ•°æ®
 569   1        PCON |= 0x80; // ä½¿èƒ½æ³¢ç‰¹ç‡åŠ å€ï¼Œä»è€Œå‡å°‘è¯¯å·®
 570   1        // æ³¨æ„51çš„ä¸²å£åªèƒ½é…ç½®å®šæ—¶å™¨1
 571   1        TMOD &= 0x0F;
 572   1        TMOD |= 0x20; // ä¸²å£éœ€è¦å®šæ—¶å™¨1è®¾ç½®ä¸º8ä½è‡ªåŠ¨é‡è£…æ¨¡å¼
 573   1        // 8ä½è‡ªåŠ¨é‡è£…æ¨¡å¼å°±æ˜¯åªèµ‹ä¸€æ¬¡åˆå€¼ï¼Œåé¢è‡ªåŠ¨è£…è½½ï¼Œè€Œæ— éœ€å†ä¸­æ–­ç¨‹åºä¸­å†è£
             -…åˆå€¼
 574   1      
 575   1        // è¿™é‡Œæ— éœ€è®¾ç½®æº¢å‡ºæ ‡å¿—ä½ï¼Œå› ä¸ºåªè¦å®šæ—¶å™¨1åœ¨è®¡æ•°æœ‰æº¢å‡ºå°±ä¼šç”Ÿæˆæ³¢ç‰¹ç‡
 576   1        TR1 = 1; // å³å¯åŠ¨å®šæ—¶å™¨1å¼€å§‹è®¡æ—¶
 577   1      
 578   1        TH1 = 0xF4; // è®¾ç½®å®šæ—¶å™¨1åˆå€¼
 579   1        TL1 = 0xF4; // è®¾ç½®å®šæ—¶å™¨1çš„è‡ªåŠ¨é‡è½½å€¼
 580   1      
 581   1        ET1 = 0; // ç¦æ­¢å®šæ—¶å™¨ä¸­æ–­,è¿™é‡Œä¸éœ€è¦å®šæ—¶å™¨ä¸­æ–­
 582   1      
 583   1        EA = 1; // æ€»ä¸­æ–­å¼€å…³é—­åˆ
 584   1        ES = 1; // ä¸²å£ä¸­æ–­å¼€å…³é—­åˆï¼Œå½“å‘é€/æ¥å—æ•°æ®æ—¶ï¼Œåˆ™è§¦å‘ä¸­æ–­
 585   1      }
 586          
 587          void UART_SendByte(unsigned char Byte)
 588          {
 589   1        SBUF = Byte;  // SBUFè´Ÿè´£æ¥æ”¶/å‘é€æ•°æ®
 590   1        while (TI == 0) // TIæ˜¯å‘é€æ§åˆ¶å™¨ï¼Œå½“å‘é€å®ŒæˆåTI=0ï¼Œå¦åˆ™ä¸º1ï¼Œ
 591   1        {       // è¿™é‡Œä¸å¯ä»¥ä¸€ç›´å‘é€ï¼Œæ‰€ä»¥éœ€è¦çŸ¥é“TIå‘é€å®Œååæ‰èƒ½ç»§ç»­å‘é€
 592   2          ;
 593   2        }
 594   1        TI = 0; // TIä¸èƒ½è‡ªåŠ¨å¤ä½ï¼Œéœ€ç¨‹åºå¤ä½ï¼Œä»¥ä¾¿ä¸‹ä¸€æ¬¡çš„åˆ¤æ–­
 595   1      }
 596          
 597          /*ä¸­æ–­ç¨‹åºè¦å†™åˆ°ä¸»å‡½æ•°æ–‡ä»¶ä¸ä¸»å‡½æ•°é…åˆ,è¿™é‡Œçš„ä¸²å£ä¸­æ–­ç¨‹åºæ˜¯ç”¨äºç”µè„‘å‘é€ç
             -»™å•ç‰‡æœºæ•°æ®ï¼Œå•ç‰‡æœºåˆ™è§¦å‘ä¸­æ–­æ¥æ¥å—æ•°æ®
 598          void UART_Routine() interrupt 4 // interrupt 4ç”¨äºå°†æ­¤å‡½æ•°å®šä¹‰ä¸ºä¸²å£ä¸­æ–­çš„ç¨‹åº
 599          {
 600            if (RI == 1) // æ¥å—ä¸­æ–­è¯·æ±‚æ ‡å¿—ä½ï¼Œ1å³æ¥å—ï¼Œå› ä¸ºå‘é€å’Œæ¥å—ä¸­æ–­æ ‡å¿—ä½æ˜¯ç”¨çš„å
C51 COMPILER V9.59.0.0   DALYA                                                             12/01/2024 17:51:25 PAGE 11  

             -Œä¸€ä¸ªæˆ–é—¨ï¼Œ
 601            {      // æ‰€ä»¥è¿™é‡Œæˆ‘ä»¬éœ€è¦åˆ¤æ–­ç©¶ç«Ÿæ˜¯å‘é€è¿˜æ˜¯æ¥å—è§¦å‘çš„ä¸­æ–­
 602              ;
 603              RI = 0; // RIä¸èƒ½è‡ªåŠ¨å¤ä½ï¼Œéœ€ç¨‹åºå¤ä½ï¼Œä»¥ä¾¿ä¸‹ä¸€æ¬¡çš„åˆ¤æ–­
 604            }
 605          }
 606          */
 607          
 608          void MatrixLED_Init()
 609          {
 610   1        SCK = 0; // ç§»ä½ä¿¡å·åˆå§‹åŒ–ä¸º0ï¼Œæ–¹ä¾¿åç»­èµ‹1ç§»ä½
 611   1        RCK = 0; // å¹¶è¡Œè¾“å‡ºä¿¡å·åˆè¯•åŒ–ä¸º0, æ–¹ä¾¿åç»­è¾“å‡º
 612   1      }
 613          
 614          void _74HC595_WriteByte(unsigned char Byte) // æ³¨æ„å‡½æ•°åä¸èƒ½ä»¥æ•°å­—å¼€å¤´
 615          {
 616   1        unsigned char i = 0;
 617   1        for (i = 0; i < 8; i++)
 618   1        {
 619   2          SER = Byte & (0x80 >> i);
 620   2          // Byteä¸1000 0000ç›¸ä¸ç¡®è®¤Byteçš„æœ€é«˜ä½(åŒç†ï¼Œä¸‹æ¬¡å¾ªç¯ï¼ŒByteä¸0100 0000ç›¸ä¸)
 621   2          // è€ŒSERæ˜¯ä¸€ä¸ªä½ï¼Œç»™å®ƒèµ‹å€¼å°±æ˜¯é0å³1ï¼Œ
 622   2          // ä¹Ÿå°±æ˜¯è¯´SERåªè¦æ¥å—éé›¶çš„æ•°å€¼å®ƒå°±æ˜¯1ï¼Œå¦åˆ™å°±æ˜¯0
 623   2          // æ‰€ä»¥è¿™æ ·å°±å¯ä»¥æå–å‡ºByteçš„1ä½æ•°å€¼
 624   2          SCK = 1; // ç»™SCKèµ‹1ç§»ä½
 625   2          SCK = 0; // ç½®0æ–¹ä¾¿ä¸‹æ¬¡ç§»ä½
 626   2        }
 627   1        RCK = 1; // å°†æ­¤8ä½æ•°æ®è¾“å‡ºå‡ºå»
 628   1        RCK = 0; // ç½®0ä»¥ä¾¿ä¸‹æ¬¡è¾“å‡º
 629   1      }
 630          
 631          // Column å³çŸ©é˜µçš„åˆ—ï¼ŒData å³åˆ—æ˜¾ç¤ºçš„æ•°æ®ï¼Œé«˜ä½åœ¨ä¸Šï¼Œ1äº®0ç­
 632          void MatrixLED_Show(unsigned char Column, unsigned char Data)
 633          {
 634   1        _74HC595_WriteByte(Data);
 635   1        P0 = ~(0x80 >> Column);
 636   1        Delay(1); // ä¸æ•°ç ç®¡ä¸€æ ·ï¼Œè¿™é‡ŒLEDç‚¹é˜µä¹Ÿè¦æ¶ˆå½±
 637   1        P0 = 0xFF;
 638   1      }
 639          
 640          void DS1302_Init(void)
 641          {
 642   1        DS1302_SCLK = 0;
 643   1        DS1302_CE = 0;
 644   1      }
 645          
 646          void DS1302_WriteByte(unsigned char command, unsigned char Date)
 647          {
 648   1        unsigned char i;
 649   1        DS1302_CE = 1;
 650   1      
 651   1        for (i = 0; i < 8; i++)
 652   1        {
 653   2          DS1302_IO = command & (0x01 << i);
 654   2          DS1302_SCLK = 1;
 655   2          DS1302_SCLK = 0;
 656   2        }
 657   1      
 658   1        for (i = 0; i < 8; i++)
 659   1        {
 660   2          DS1302_IO = Date & (0x01 << i);
 661   2          DS1302_SCLK = 1;
C51 COMPILER V9.59.0.0   DALYA                                                             12/01/2024 17:51:25 PAGE 12  

 662   2          DS1302_SCLK = 0;
 663   2        }
 664   1        DS1302_CE = 0;
 665   1      }
 666          
 667          unsigned char DS1302_ReadByte(unsigned char command)
 668          {
 669   1        unsigned char i;
 670   1        unsigned char Data = 0x00;
 671   1        command |= 0x01; // è¿™ä¸€å¥çš„ä½œç”¨å°±åœ¨äºï¼Œç»™å‡½æ•°DS1302_ReadByteå†™çš„åœ°å€ï¼Œç„¶å
 672   1                 // æœ€åä¸€ä½ç½®1å°±æ˜¯å¯¹åº”è¯»çš„åœ°å€
 673   1      
 674   1        DS1302_CE = 1;
 675   1        for (i = 0; i < 8; i++)
 676   1        {
 677   2          DS1302_IO = command & (0x01 << i);
 678   2          DS1302_SCLK = 0;
 679   2          DS1302_SCLK = 1;
 680   2        }
 681   1      
 682   1        for (i = 0; i < 8; i++)
 683   1        {
 684   2          DS1302_SCLK = 1;
 685   2          DS1302_SCLK = 0;
 686   2          if (DS1302_IO)
 687   2          {
 688   3            Data |= (0x01 << i);
 689   3          }
 690   2        }
 691   1        DS1302_CE = 0;
 692   1        DS1302_IO = 0;
 693   1      
 694   1        return Data;
 695   1      }
 696          
 697          char DS1302_Time[7] = {23, 11, 19, 15, 41, 0, 6};
 698          
 699          void DS1302_SetTime(void)
 700          {
 701   1        DS1302_WriteByte(DS1302_WP, 0x00); // å…³é—­å†™ä¿æŠ¤
 702   1      
 703   1        DS1302_WriteByte(DS1302_YEAR, DS1302_Time[0] / 10 * 16 + DS1302_Time[0] % 10);
 704   1        DS1302_WriteByte(DS1302_MONTH, DS1302_Time[1] / 10 * 16 + DS1302_Time[1] % 10);
 705   1        DS1302_WriteByte(DS1302_DATE, DS1302_Time[2] / 10 * 16 + DS1302_Time[2] % 10);
 706   1        DS1302_WriteByte(DS1302_HOUR, DS1302_Time[3] / 10 * 16 + DS1302_Time[3] % 10);
 707   1        DS1302_WriteByte(DS1302_MINUTE, DS1302_Time[4] / 10 * 16 + DS1302_Time[4] % 10);
 708   1        DS1302_WriteByte(DS1302_SECOND, DS1302_Time[5] / 10 * 16 + DS1302_Time[5] % 10);
 709   1        DS1302_WriteByte(DS1302_DAY, DS1302_Time[6] / 10 * 16 + DS1302_Time[6] % 10);
 710   1      
 711   1        DS1302_WriteByte(DS1302_WP, 0x80); // æ‰“å¼€å†™ä¿æŠ¤
 712   1      }
 713          
 714          void DS1302_ReadTime(void)
 715          {
 716   1        unsigned char Temp; // ä¸­é—´å˜é‡
 717   1      
 718   1        Temp = DS1302_ReadByte(DS1302_YEAR);
 719   1        DS1302_Time[0] = Temp / 16 * 10 + Temp % 16;
 720   1        Temp = DS1302_ReadByte(DS1302_MONTH);
 721   1        DS1302_Time[1] = Temp / 16 * 10 + Temp % 16;
 722   1        Temp = DS1302_ReadByte(DS1302_DATE);
 723   1        DS1302_Time[2] = Temp / 16 * 10 + Temp % 16;
C51 COMPILER V9.59.0.0   DALYA                                                             12/01/2024 17:51:25 PAGE 13  

 724   1        Temp = DS1302_ReadByte(DS1302_HOUR);
 725   1        DS1302_Time[3] = Temp / 16 * 10 + Temp % 16;
 726   1        Temp = DS1302_ReadByte(DS1302_MINUTE);
 727   1        DS1302_Time[4] = Temp / 16 * 10 + Temp % 16;
 728   1        Temp = DS1302_ReadByte(DS1302_SECOND);
 729   1        DS1302_Time[5] = Temp / 16 * 10 + Temp % 16;
 730   1        Temp = DS1302_ReadByte(DS1302_DAY);
 731   1        DS1302_Time[6] = Temp / 16 * 10 + Temp % 16;
 732   1      }
 733          
 734          void I2C_Start(void) // I2Cå¼€å§‹
 735          {
 736   1        I2C_SCL = 1;
 737   1        I2C_SDA = 1;
 738   1        I2C_SDA = 0;
 739   1        I2C_SCL = 0;
 740   1      }
 741          
 742          void I2C_Stop(void) // I2Cåœæ­¢
 743          {
 744   1        I2C_SDA = 0;
 745   1        I2C_SCL = 1;
 746   1        I2C_SDA = 1;
 747   1      }
 748          
 749          void I2C_SendByte(unsigned char Byte) // I2Cå‘é€ä¸€ä¸ªå­—èŠ‚ï¼ŒByteå³è¦å‘é€çš„å­—èŠ‚
 750          {
 751   1        unsigned char i;
 752   1        for (i = 0; i < 8; i++)
 753   1        {
 754   2          I2C_SDA = Byte & (0x80 >> i); // ä¾æ¬¡å–å‡ºByteçš„ä½
 755   2          I2C_SCL = 1;
 756   2          I2C_SCL = 0;
 757   2        }
 758   1      }
 759          
 760          unsigned char I2C_ReceiveByte(void) // I2Cæ¥æ”¶ä¸€ä¸ªå­—èŠ‚å¹¶è¿”å›
 761          {
 762   1        unsigned char Byte = 0x00;
 763   1        unsigned char i = 0;
 764   1      
 765   1        I2C_SDA = 1;
 766   1      
 767   1        for (i = 0; i < 8; i++)
 768   1        {
 769   2          I2C_SCL = 1;
 770   2          if (I2C_SDA)
 771   2          {
 772   3            Byte |= (0x80 >> i);
 773   3          }
 774   2          I2C_SCL = 0;
 775   2        }
 776   1      
 777   1        return Byte;
 778   1      }
 779          
 780          void I2C_SendAck(unsigned char AckBit) // I2Cä¸»æœºå‘é€åº”ç­”ï¼ŒAckBitä¸ºåº”ç­”ï¼Œ0åº”ç­”ï¼Œ1éåº”ç­”
 781          {
 782   1        I2C_SDA = AckBit;
 783   1        I2C_SCL = 1;
 784   1        I2C_SCL = 0;
 785   1      }
C51 COMPILER V9.59.0.0   DALYA                                                             12/01/2024 17:51:25 PAGE 14  

 786          
 787          unsigned char I2C_ReceiveAck(void) // I2Cä¸»æœºæ¥æ”¶åº”ç­”
 788          {
 789   1        unsigned char AckBit;
 790   1        I2C_SDA = 1;
 791   1        I2C_SCL = 1;
 792   1        AckBit = I2C_SDA;
 793   1        I2C_SCL = 0;
 794   1        return AckBit;
 795   1      }
 796          
 797          // æ³¨æ„è¾“å…¥çš„WordAddressæ˜¯8ä½åœ°å€ï¼Œæ‰€ä»¥å–å€¼åº”æ˜¯0~255
 798          void AT24C02_WriterByte(unsigned char WordAddress, unsigned char Data)
 799          {
 800   1        I2C_Start();
 801   1        I2C_SendByte(AT24C02_ADDRESS);
 802   1        I2C_ReceiveAck();
 803   1        I2C_SendByte(WordAddress);
 804   1        I2C_ReceiveAck();
 805   1        I2C_SendByte(Data);
 806   1        I2C_ReceiveAck();
 807   1        I2C_Stop();
 808   1      }
 809          
 810          // æ³¨æ„è¾“å…¥çš„WordAddressæ˜¯8ä½åœ°å€ï¼Œæ‰€ä»¥å–å€¼åº”æ˜¯0~255
 811          unsigned char AT24C02_ReadByte(unsigned char WordAddress)
 812          {
 813   1        unsigned char Data = 0;
 814   1        I2C_Start();
 815   1        I2C_SendByte(AT24C02_ADDRESS);
 816   1        I2C_ReceiveAck();
 817   1        I2C_SendByte(WordAddress);
 818   1        I2C_ReceiveAck();
 819   1        I2C_Start();
 820   1        I2C_SendByte(AT24C02_ADDRESS | 0x01);
 821   1        I2C_ReceiveAck();
 822   1        Data = I2C_ReceiveByte();
 823   1        I2C_SendAck(1);
 824   1        I2C_Stop();
 825   1      
 826   1        return Data;
 827   1      }
 828          
 829          unsigned char OneWire_Init(void)
 830          {
 831   1        unsigned char i;
 832   1        unsigned char AckBit;
 833   1        OneWire_DQ = 1;
 834   1        OneWire_DQ = 0; // ä¸»æœºæ‹‰ä½
 835   1      
 836   1        i = 218;
 837   1        while (--i)
 838   1          ; // Delay 500us
 839   1      
 840   1        OneWire_DQ = 1; // ä¸»æœºé‡Šæ”¾
 841   1      
 842   1        i = 29;
 843   1        while (--i)
 844   1          ; // Delay 70us
 845   1      
 846   1        AckBit = OneWire_DQ;
 847   1      
C51 COMPILER V9.59.0.0   DALYA                                                             12/01/2024 17:51:25 PAGE 15  

 848   1        i = 218;
 849   1        while (--i)
 850   1          ; // Delay 500us
 851   1      
 852   1        return AckBit;
 853   1      }
 854          
 855          void OneWire_SendBit(unsigned char Bit)
 856          {
 857   1        unsigned char i;
 858   1        OneWire_DQ = 0; // ä¸»æœºæ‹‰ä½
 859   1      
 860   1        i = 3;
 861   1        while (--i)
 862   1          ; // Delay 10us
 863   1      
 864   1        OneWire_DQ = Bit;
 865   1      
 866   1        i = 22;
 867   1        while (--i)
 868   1          ; // Delay 50us
 869   1      
 870   1        OneWire_DQ = 1;
 871   1      }
 872          
 873          unsigned char OneWire_ReceiveBit(void)
 874          {
 875   1        unsigned char i;
 876   1        unsigned char Bit;
 877   1      
 878   1        OneWire_DQ = 0; // ä¸»æœºæ‹‰ä½
 879   1      
 880   1        i = 1;
 881   1        while (--i)
 882   1          ; // Delay 5us
 883   1      
 884   1        OneWire_DQ = 1; // ä¸»æœºé‡Šæ”¾
 885   1      
 886   1        i = 1;
 887   1        while (--i)
 888   1          ; // Delay 5us
 889   1      
 890   1        Bit = OneWire_DQ;
 891   1      
 892   1        i = 22;
 893   1        while (--i)
 894   1          ; // Delay 50us
 895   1      
 896   1        return Bit;
 897   1      }
 898          
 899          void OneWire_SendByte(unsigned char Byte)
 900          {
 901   1        unsigned char i;
 902   1        for (i = 0; i < 8; i++)
 903   1        {
 904   2          OneWire_SendBit(Byte & (0x01 << i));
 905   2        }
 906   1      }
 907          
 908          unsigned char OneWire_ReceiveByte(void)
 909          {
C51 COMPILER V9.59.0.0   DALYA                                                             12/01/2024 17:51:25 PAGE 16  

 910   1        unsigned char i;
 911   1        unsigned char Byte = 0x00;
 912   1        for (i = 0; i < 8; i++)
 913   1        {
 914   2          if (OneWire_ReceiveBit())
 915   2          {
 916   3            Byte |= (0x01 << i);
 917   3          }
 918   2        }
 919   1        return Byte;
 920   1      }
 921          
 922          void DS18B20_ConvertT(void)
 923          {
 924   1        OneWire_Init();
 925   1        OneWire_SendByte(DS18B20_SKIP_ROM);
 926   1        OneWire_SendByte(DS18B20_CONVERT_T);
 927   1      }
 928          
 929          float DS18B20_ReadT(void)
 930          {
 931   1        unsigned char TLSB = 0;
 932   1        unsigned char TMSB = 0;
 933   1        int Temp;
 934   1        float T;
 935   1      
 936   1        OneWire_Init();
 937   1        OneWire_SendByte(DS18B20_SKIP_ROM);
 938   1        OneWire_SendByte(DS18B20_READ_SCRATCHPAD);
 939   1      
 940   1        TLSB = OneWire_ReceiveByte();
 941   1        TMSB = OneWire_ReceiveByte();
 942   1      
 943   1        Temp = (TMSB << 8) | TLSB;
 944   1        T = Temp / 16.0; // å°†æœ€å4ä½æ•°æ®ç§»åŠ¨åˆ°å°æ•°ä½
 945   1      
 946   1        return T;
 947   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2071    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     32      29
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
